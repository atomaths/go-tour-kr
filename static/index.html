
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>A Tour of Go</title>


<script src="/static/jquery.js"></script>


<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/lib/go.js"></script>


<link rel="stylesheet" href="static/tour.css">
<script src="/static/lang.js"></script>
<script src="/static/tour.js"></script>

</head>
<body>
	<div id="wrap">
		<div id="header">
			<div id="slidenum">1</div>
				<a href="#toc" id="tocbtn" title="Table of Contents"></a>
				<h1>A Tour of Go</h1>
			</div>

<div id="slides" class="slides">


<div class="slide">
	
  <h2>Hello, 안녕</h2>
  
  
  <p>
    <a href="http://golang.org" target="_blank">Go 프로그래밍 언어</a> 투어에 오신 것을 환영합니다.
  </p>
  

  
  <p>
    이 투어는 3개의 섹션으로 되어 있고, 각 섹션의 마지막 부분에는 좀더 완벽한 이해를 돕기 위해 연습문제가 준비되어 있습니다.
  </p>
  

  
  <p>
    지금 Run 버튼을 클릭해보거나 키보드에서 Shift-Enter 키를 눌러보세요. 옆의 Go 소스가 컴파일되고 실행될 겁니다. 실행 결과는 코드 밑에 표시됩니다.
  </p>
  

  
  <p>
    이 투어에 있는 많은 예제 프로그램들은 Go가 다른 언어들과 어떤 차이점이 있는지 보여줄 것이고, 여러분이 Go를 배우는데 출발점이 될 것입니다.
  </p>
  

  
  <p>
    소스를 수정하고 다시 한번 실행해보세요.
  </p>
  

  
  <p>
    이제 다음으로 넘어갈 준비가 되었으면, Next 버튼을 클릭하거나 PageDown 키를 누르세요.
  </p>
  

  <div class="source"><!--{{.play prog/hello.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    fmt.Println(&#34;Hello, 안녕&#34;)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide nocode">
	
  <h2>Go local</h2>
  
  
  <p>
    이 투어는 다른 나라 언어로도 이용할 수 있습니다:
  </p>
  

  <ul>
  
    <li><a href="http://go-tour-br.appspot.com/" target="_blank">Brazilian Portuguese — Português do Brasil</a></li>
  
    <li><a href="http://go-tour-he.appspot.com/" target="_blank">Hebrew — עִבְרִית</a></li>
  
    <li><a href="http://go-tour-zh.appspot.com/" target="_blank">Chinese — 普通话</a></li>
  
    <li><a href="http://go-tour-jp.appspot.com/" target="_blank">Japanese — 日本語</a></li>
  
    <li><a href="http://go-tour-kr.appspot.com/" target="_blank">Korean — 한국어</a></li>
  
  </ul>

  
  <p>
    계속 하시려면 Next 버튼을 클릭하거나 PageDown 키를 누르세요.
  </p>
  


</div>

<div class="slide nocode">
	
  <h2>Go offline</h2>
  
  
  <p>
    Go Tour는 인터넷 연결없이 stand-alone 프로그램으로도 사용할 수 있습니다.
  </p>
  

  
  <p>
    stand-alone으로 Go Tour를 이용하면 예제 코드들이 로컬 머신에서 빌드되고 실행되기 때문에 보다 빠릅니다. 그리고 웹버전에는 가능하지 않은 추가적인 연습문제들을 포함하고 있습니다.
  </p>
  

  
  <p>
    이 투어를 로컬에서 실행하기 위해 먼저 <a href="http://golang.org/doc/install/" target="_blank">Go를 설치</a> 하고, <a href="http://code.google.com/p/go-tour/" target="_blank">gotour</a>를 설치하기 위해 <a href="http://golang.org/cmd/go/" target="_blank">go get</a>을 명령을 이용하면 됩니다.
  </p>
  

  
  <pre>go get code.google.com/p/go-tour/gotour</pre>
  

  
  <p>
    그리고 위 결과로 생긴 <code>gotour</code> 를 실행하세요.
  </p>
  

  
  <p>
    오프라인 모드를 사용하지 않고 계속 진행하려면, &quot;next&quot; 버튼이나 PageDown 키를 누르세요.
  </p>
  

  
  <p>
    <i>(언제든 &quot;index&quot; 버튼을 누르면 원하는 특별한 챕터로 이동할 수 있습니다.)</i>
  </p>
  


</div>

<div class="slide">
	
  <h2>패키지(Packages)</h2>
  
  
  <p>
    모든 Go 프로그램은 패키지로 구성되어 있습니다.
  </p>
  

  
  <p>
    프로그램은 <code>main</code> 패키지에서부터 실행을 시작합니다.
  </p>
  

  
  <p>
    이 프로그램은 `&quot;fmt&quot;`와 <code>&quot;math&quot;</code> 패키지를 import 해서 사용하고 있습니다.
  </p>
  

  
  <p>
    패키지 이름은 디렉토리 경로의 마지막 이름을 사용하는 것이 규칙입니다. 
  </p>
  

  
  <p>
    예를 들어 <code>&quot;path/filepath&quot;</code> 를 사용한다면 패키지명은 <code>filepath</code> 입니다.
  </p>
  

  <div class="source"><!--{{.play prog/packages.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func main() {
    fmt.Println(&#34;Happy&#34;, math.Pi, &#34;Day&#34;)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>임포트 (Imports)</h2>
  
  
  <p>
    이 코드에서는 여러개의 <code>&quot;package&quot;</code> 를 소괄호로 감싸서 import를 표현합니다. 아래와 같이 import 문장을 여러번 사용할 수 도 있습니다.
  </p>
  

  
  <pre>import &#34;fmt&#34;
import &#34;math&#34;</pre>
  

  <div class="source"><!--{{.play prog/imports.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func main() {
    fmt.Printf(&#34;Now you have %g problems.&#34;,
        math.Nextafter(2, 3))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>익스포트 (Exported names)</h2>
  
  
  <p>
    패키지를 Import 하면 패키지가 외부로 export 한 것들(메서드나 변수, 상수 등)에 접근할 수 있습니다.
  </p>
  

  
  <p>
    Go에서는 첫 문자가 대문자로 시작하면 그 패키지를 사용하는 곳에서 접근할 수 있는 exported name이 됩니다.
  </p>
  

  
  <p>
    예를 들어 <code>Foo</code> 와 <code>FOO</code> 는 외부에서 참조할 수 있지만 <code>foo</code> 는 참조 할 수 없습니다.
  </p>
  

  
  <p>
    예제를 실행해보세요. 에러가 발생한다면 <code>math.pi</code> 를 <code>math.Pi</code> 로 변경 해보세요.
  </p>
  

  <div class="source"><!--{{.play prog/exported-names.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func main() {
    fmt.Println(math.pi)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>함수 (1)</h2>
  
  
  <p>
    함수는 매개변수(인자)를 가질 수 있습니다.
  </p>
  

  
  <p>
    예를 들어 <code>add</code> 라는 함수는 두개의 <code>int</code> 타입 매개변수를 받습니다.
  </p>
  

  
  <p>
    C, C++, Java 언어와 다르게 매개변수의 타입은 변수명 <i>뒤에</i> 명시합니다.
  </p>
  

  
  <p>
    (타입을 왜 변수명 뒤에 명시하는지에 대한 자세한 내용은 <a href="http://golang.org/doc/articles/gos_declaration_syntax.html" target="_blank">Go&apos;s declaration syntax</a>를 참고하시기 바랍니다. 간단히 설명하면 코드를 왼쪽에서 오른쪽으로 읽을 때 자연스럽게 읽기 위해서 입니다.)
  </p>
  

  <div class="source"><!--{{.play prog/functions.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>함수 (2)</h2>
  
  
  <p>
    두 개 이상의 매개변수가 같은 타입(type)일 때, 같은 타입을 취하는 마지막 매개변수에만 타입을 명시하고 나머지는 생략할 수 있습니다.
  </p>
  

  
  <p>
    예를 들어
  </p>
  

  
  <pre>x int, y int</pre>
  

  
  <p>
    과 같은 문장은 아래와 같이 표현할 수 있습니다.
  </p>
  

  
  <pre>x, y int</pre>
  

  <div class="source"><!--{{.play prog/functions-continued.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>여러 개의 결과 (Multiple results)</h2>
  
  
  <p>
    하나의 함수는 여러 개의 결과를 반환할 수 있습니다.
  </p>
  

  
  <p>
    예제 코드에서의 함수는 두개의 문자열을 반환합니다.
  </p>
  

  <div class="source"><!--{{.play prog/multiple-results.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&#34;hello&#34;, &#34;world&#34;)
    fmt.Println(a, b)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>이름이 정해진 결과 (Named results)</h2>
  
  
  <p>
    함수는 매개변수를 취합니다. Go에서 함수는 여러 개의 결과를 반환할 수 있습니다. 반환 값에 이름을 부여하면 변수처럼 사용할 수도 있습니다.
  </p>
  

  
  <p>
    결과에 이름을 붙히면, 반환 값을 지정하지 않은 <code>return</code> 문장으로 결과의 현재 값을 알아서 반환합니다.
  </p>
  

  <div class="source"><!--{{.play prog/named-results.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>변수 (Variables)</h2>
  
  
  <p>
    변수를 선언을 위해 <code>var</code> 을 사용합니다.
  </p>
  

  
  <p>
    함수의 매개변수처럼 타입은 문장 끝에 명시합니다.
  </p>
  

  <div class="source"><!--{{.play prog/variables.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

var x, y, z int
var c, python, java bool

func main() {
    fmt.Println(x, y, z, c, python, java)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>변수의 초기화</h2>
  
  
  <p>
    변수 선언과 함께 변수 각각을 초기화를 할 수 있습니다.
  </p>
  

  
  <p>
    초기화를 하는 경우 타입(type)을 생략할 수 있습니다. 변수는 초기화 하고자 하는 값에 따라 타입이 결정됩니다.
  </p>
  

  <div class="source"><!--{{.play prog/variables-with-initializers.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

var x, y, z int = 1, 2, 3
var c, python, java = true, false, &#34;no!&#34;

func main() {
    fmt.Println(x, y, z, c, python, java)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>변수의 짧은 선언</h2>
  
  
  <p>
    함수 내에서 <code>:=</code> 을 사용하면 <code>var</code> 과 명시적인 타입(e.g. int, bool) 을 생략할 수 있습니다.
  </p>
  

  
  <p>
    (그러나 함수 밖에서는 <code>:=</code> 선언을 사용할 수 없습니다.)
  </p>
  

  <div class="source"><!--{{.play prog/short-variable-declarations.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    var x, y, z int = 1, 2, 3
    c, python, java := true, false, &#34;no!&#34;

    fmt.Println(x, y, z, c, python, java)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>상수 (Constants)</h2>
  
  
  <p>
    상수는 <code>const</code> 키워드와 함께 변수처럼 선언합니다.
  </p>
  

  
  <p>
    상수는 문자(character), 문자열(string), 부울(boolean), 숫자 타입 중의 하나가 될 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/constants.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

const Pi = 3.14

func main() {
    const World = &#34;안녕&#34;
    fmt.Println(&#34;Hello&#34;, World)
    fmt.Println(&#34;Happy&#34;, Pi, &#34;Day&#34;)

    const Truth = true
    fmt.Println(&#34;Go rules?&#34;, Truth)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>숫자형 상수 (Numeric Constants)</h2>
  
  
  <p>
    숫자형 상수는 <i>정밀한 값(values)</i> 을 표현할 수 있습니다.
  </p>
  

  
  <p>
    타입을 지정하지 않은 상수는 문맥(context)에 따라 타입을 가지게 됩니다.
  </p>
  

  
  <p>
    코드를 통해 <code>needInt(Big)</code> 는 어떤 결과를 출력할지 실험해보세요.
  </p>
  

  <div class="source"><!--{{.play prog/numeric-constants.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

const (
    Big   = 1 &lt;&lt; 100
    Small = Big &gt;&gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>For (반복문 for)</h2>
  
  
  <p>
    Go 언어는 반복문이 <code>for</code> 밖에 없습니다.
  </p>
  

  
  <p>
    기본적인 <code>for</code> 반복문은 C와 Java 언어와 거의 유사합니다. 다른점은 소괄호 ( )가 필요하지 않다는 것입니다.
  </p>
  

  
  <p>
    하지만 실행문을 위한 중괄호 { } 는 필요합니다.
  </p>
  

  <div class="source"><!--{{.play prog/for.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    sum := 0
    for i := 0; i &lt; 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>For (2)</h2>
  
  
  <p>
    C와 Java에서 처럼 전.후 처리를 제외하고 조건문만 표현할 수도 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/for-continued.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>Go에서 &#34;While&#34; 사용하기</h2>
  
  
  <p>
    이전의 예제에서 처럼 조건문만 표시하면 C언어에서 <code>while</code> 을 사용하듯 <code>for</code> 를 사용할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/for-is-gos-while.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>무한 루프</h2>
  
  
  <p>
    for에서 조건문을 생략하면 무한 루프를 간단하게 표현할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/forever.go}}
--><pre style="display: none"></pre><pre>package main

func main() {
    for {
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>조건문 (If)</h2>
  
  
  <p>
    <code>if</code> 문은 C와 Java와 비슷합니다. 조건 표현을 위해 <code>( )</code> 는 사용하지 않습니다. 하지만 실행문을 위한 <code>{ }</code> 는 반드시 작성해야합니다.
  </p>
  

  
  <p>
    (For문과 비슷하죠?)
  </p>
  

  <div class="source"><!--{{.play prog/if.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func sqrt(x float64) string {
    if x &lt; 0 {
        return sqrt(-x) + &#34;i&#34;
    }
    return fmt.Sprint(math.Sqrt(x))
}

func main() {
    fmt.Println(sqrt(2), sqrt(-4))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>If와 짧은 명령 사용하기</h2>
  
  
  <p>
    <code>for</code> 처럼 <code>if</code> 에서도 조건문 앞에 짧은 문장을 실행할 수 있습니다.
  </p>
  

  
  <p>
    예제에서는 조건을 비교하기 전에 `v := math.Pow(x,n)` 을 실행했습니다.
  </p>
  

  
  <p>
    짧은 실행문을 통해 선언된 변수는 <code>if</code> <i>안쪽 범위(scope)</i> 에서 만 사용할 수 있습니다.
  </p>
  

  
  <p>
    (예제 코드의 <code>pow</code> 함수에서 <code>return</code> 전에 <code>v</code> 를 사용해보세요.)
  </p>
  

  <div class="source"><!--{{.play prog/if-with-a-short-statement.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    }
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>If와 else</h2>
  
  
  <p>
    <code>if</code> 에서 짧은 명령문을 통해 선언된 변수는 <code>else</code> 블럭 안에서도 사용할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/if-and-else.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    } else {
        fmt.Printf(&#34;%g &gt;= %g\n&#34;, v, lim)
    }
    // can&#39;t use v here, though
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 루프와 함수</h2>

  
  <p>
    함수와 루프의 사용법을 익히는 간단한 연습으로, 제곱근 함수를 뉴턴의 방법(Newton&apos;s method)을 이용하여 구현합니다.
  </p>
  

  
  <p>
    여기서 뉴턴의 방법이란 초기값 <i>z</i>를 선택한 후에 다음의 공식을 이용하여 반복적으로 <code>Sqrt(x)</code> 함수의 근사값을 찾아가는 방법을 말합니다:
  </p>
  
  <p>
    z = z - (z * z - x) / (2 * z)
  </p>

  
  <p>
    처음에는 계산을 10번만 반복하여 여러분이 작성한 함수가 다양한 값들 (1, 2, 3, ...)에 대하여 얼마나 정확한 값을 찾아내는지 확인합니다.
  </p>
  

  
  <p>
    그 다음에는, 루프의 조건을 수정하여 값이 더이상 바뀌지 않을 때 (혹은 아주 작은 차이가 발생할 때) 루프를 종료하도록 합니다. 이렇게 하면 반복문의 실행 횟수가 어떻게 달라지는지 확인합니다. 결과값이 <a href="http://golang.org/pkg/math/#Sqrt" target="_blank">math.Sqrt</a> 함수의 값과 얼마나 비슷한가요?                                                   
  </p>
  

  
  <p>
    힌트: 실수(floating point)값을 선언하고 초기화 하려면, 실수값을 표현하는 문법을 사용하거나 변환 함수를 사용합니다:
  </p>
  

  
  <pre>z := float64(1)
z := 1.0</pre>
  

  <div class="source"><!--{{.play prog/exercise-loops-and-functions.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
)

func Sqrt(x float64) float64 {
}

func main() {
    fmt.Println(Sqrt(2))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>기본 자료형</h2>
  
  
  <p>
    Go의 기본 자료형은 아래와 같습니다.
  </p>
  

  
  <pre>bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8의 다른 이름(alias)

rune // int32의 다른 이름(alias)
     // 유니코드 코드 포인트 값을 표현합니다. 

float32 float64

complex64 complex128</pre>
  

  <div class="source"><!--{{.play prog/basic-types.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math/cmplx&#34;
)

var (
    ToBe   bool       = false
    MaxInt uint64     = 1&lt;&lt;64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = &#34;%T(%v)\n&#34;
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>구조체 (Structs)</h2>
  
  
  <p>
    <code>struct</code> 는 필드(데이터)들의 조합입니다.
  </p>
  

  
  <p>
    (그리고 <code>type</code> 선언으로 struct의 이름을 지정할 수 있습니다.)
  </p>
  

  <div class="source"><!--{{.play prog/structs.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    X int
    Y int
}

func main() {
    fmt.Println(Vertex{1, 2})
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>구조체 필드</h2>
  
  
  <p>
    구조체에 속한 필드(데이터)는 dot(.) 으로 접근합니다.
  </p>
  

  <div class="source"><!--{{.play prog/struct-fields.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>포인터 (Pointers)</h2>
  
  
  <p>
    Go에는 포인터가 있지만 포인터 연산은 불가능합니다.
  </p>
  

  
  <p>
    구조체 변수는 구조체 포인터를 이용해서 접근 할 수 있습니다.
  </p>
  

  
  <p>
    포인터를 이용하는 간접적인 접근은 실제 구조체에도 영향을 미칩니다.
  </p>
  

  <div class="source"><!--{{.play prog/pointers.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    X int
    Y int
}

func main() {
    p := Vertex{1, 2}
    q := &amp;p
    q.X = 1e9
    fmt.Println(p)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>구조체 리터럴 (Struct Literals)</h2>
  
  
  <p>
    구조체 리터럴은 필드와 값을 나열해서 구조체를 새로 할당하는 방법입니다.
  </p>
  

  
  <p>
    원하는 필드를 `{Name: value}` 구문을 통해 할당할 수 있습니다. (필드의 순서는 상관 없습니다.)
  </p>
  

  
  <p>
    특별한 접두어 <code>&amp;</code> 를 사용하면 구조체 리터럴에 대한 포인터를 생성할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/struct-literals.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    X, Y int
}

var (
    p = Vertex{1, 2}  // has type Vertex
    q = &amp;Vertex{1, 2} // has type *Vertex
    r = Vertex{X: 1}  // Y:0 is implicit
    s = Vertex{}      // X:0 and Y:0
)

func main() {
    fmt.Println(p, q, r, s)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>new 함수</h2>
  
  
  <p>
    <code>new(T)</code> 는 모든 필드가 <i>0(zero value)</i> 이 할당된 <code>T</code> 타입의 포인터를 반환합니다.
  </p>
  

  
  <p>
    ( <i>zero value</i> 는 숫자 타입에서는 <code>0</code> , 참조 타입에서는 <code>nil</code> 을 뜻합니다 )
  </p>
  

  
  <pre>var t *T = new(T)</pre>
  

  
  <p>
    또는
  </p>
  

  
  <pre>t := new(T)</pre>
  

  
  <p>
    위의 변수 t는 <code>T</code> 에서 반환된 포인터를 가집니다.
  </p>
  

  <div class="source"><!--{{.play prog/the-new-function.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    X, Y int
}

func main() {
    v := new(Vertex)
    fmt.Println(v)
    v.X, v.Y = 11, 9
    fmt.Println(v)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>슬라이스 (Slices)</h2>
  
  
  <p>
    슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다.
  </p>
  

  
  <p>
    <code>[]T</code> 는 타입 <code>T</code> 를 가지는 요소의 슬라이스(slice) 입니다.
  </p>
  

  <div class="source"><!--{{.play prog/slices.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    p := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(&#34;p ==&#34;, p)

    for i := 0; i &lt; len(p); i++ {
        fmt.Printf(&#34;p[%d] == %d\n&#34;,
            i, p[i])
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>슬라이스 자르기 (Slicing slices)</h2>
  
  
  <p>
    슬라이스는 재분할 할 수도 있고, 같은 배열을 가리키는(point) 새로운 슬라이스를 만들 수 도 있습니다.
  </p>
  

  
  <p>
    예제로 살펴보면
  </p>
  

  
  <pre>s[lo:hi]</pre>
  

  
  <p>
    위의 표현은 <code>lo</code> 에서 <code>hi-1</code> 의 요소(element)를 포함하는 슬라이스입니다. 따라서
  </p>
  

  
  <pre>s[lo:lo]</pre>
  

  
  <p>
    는 빈(empty) 슬라이스 이고
  </p>
  

  
  <pre>s[lo:lo&#43;1]</pre>
  

  
  <p>
    는 하나의 요소를 가집니다.
  </p>
  

  <div class="source"><!--{{.play prog/slicing-slices.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    p := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(&#34;p ==&#34;, p)
    fmt.Println(&#34;p[1:4] ==&#34;, p[1:4])

    // missing low index implies 0
    fmt.Println(&#34;p[:3] ==&#34;, p[:3])

    // missing high index implies len(s)
    fmt.Println(&#34;p[4:] ==&#34;, p[4:])
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>슬라이스 만들기</h2>
  
  
  <p>
    슬라이스는 <code>make</code> 함수로 만들 수 있습니다. 이렇게 생성된 슬라이스는 0을 할당한 배열을 생성하고, 그것을 참조(refer)합니다.
  </p>
  

  
  <pre>a := make([]int, 5)  // len(a)=5</pre>
  

  
  <p>
    <code>make</code> 함수의 세번째 매개변수로 용량(capacity)를 제한할 수 있습니다.
  </p>
  

  
  <pre>b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4</pre>
  

  <div class="source"><!--{{.play prog/making-slices.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    a := make([]int, 5)
    printSlice(&#34;a&#34;, a)
    b := make([]int, 0, 5)
    printSlice(&#34;b&#34;, b)
    c := b[:2]
    printSlice(&#34;c&#34;, c)
    d := c[2:5]
    printSlice(&#34;d&#34;, d)
}

func printSlice(s string, x []int) {
    fmt.Printf(&#34;%s len=%d cap=%d %v\n&#34;,
        s, len(x), cap(x), x)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>빈 슬라이스</h2>
  
  
  <p>
    슬라이스의 zero value는 <code>nil</code> 입니다.
  </p>
  

  
  <p>
    nil 슬라이스는 길이와 최대 크기가 0입니다.
  </p>
  

  
  <p>
    (슬라이스에 대해 더 알고 싶다면 다음 글을 읽어보세요. <a href="http://golang.org/doc/articles/slices_usage_and_internals.html" target="_blank">Slices: usage and internals</a>)
  </p>
  

  <div class="source"><!--{{.play prog/nil-slices.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    var z []int
    fmt.Println(z, len(z), cap(z))
    if z == nil {
        fmt.Println(&#34;nil!&#34;)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>레인지 (Range, 범위)</h2>
  
  
  <p>
    <code>for</code> 반복문에서 <code>range</code> 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/range.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&#34;2**%d = %d\n&#34;, i, v)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>레인지 (2)</h2>
  
  
  <p>
    <code>_</code> 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다.
  </p>
  

  
  <p>
    만약 인덱스만 필요하다면 “ `, value` ” 부분을 다 제거하면 됩니다.
  </p>
  

  
  <pre>for i, value := range pow {
	pow[i] = 1 &lt;&lt; uint(i)
}</pre>
  

  
  <p>
    에서
  </p>
  

  
  <pre>for i := range pow {
	pow[i] = 1 &lt;&lt; uint(i)
}</pre>
  

  
  <p>
    처럼 사용할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/range-continued.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    pow := make([]int, 10)
    for i := range pow {
        pow[i] = 1 &lt;&lt; uint(i)
    }
    for _, value := range pow {
        fmt.Printf(&#34;%d\n&#34;, value)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 슬라이스</h2>
  
  
  <p>
    <code>Pic</code>이라는 함수를 구현합니다. 이 함수는 <code>dy</code>개 만큼의 길이를 가지는 슬라이스를 리턴해야 하는데, 각각의 요소들은 또한 <code>dx</code> 개의 8비트 부호없는 8비트 정수 타입을 가지는 슬라이스입니다. 프로그램을 실행하면 이 정수값들을 흑백 (사실은 파란색)을 나타내는 값으로 해석하여 그림을 보여줄 것입니다.
  </p>
  

  
  <p>
    그림은 여러분이 원하는 것으로 선택할 수 있습니다. (이용할 수 있는) 흥미로운 함수로는 <code>x^y</code>, <code>(x+y)/2</code>, <code>x*y</code> 등이 있습니다.
  </p>
  

  
  <p>
    (여러분은 <code>[][]uint8</code> 슬라이스 내에서 사용할 각각의 <code>[]uint8</code> 슬라이스를 할당하기 위해 루프를 활용해야 할 것입니다.)
  </p>
  

  
  <p>
    (타입 간의 변환을 위해서는 <code>uint8(intValue)</code>을 사용합니다.)
  </p>
  

  <div class="source"><!--{{.play prog/exercise-slices.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;code.google.com/p/go-tour/pic&#34;

func Pic(dx, dy int) [][]uint8 {
}

func main() {
    pic.Show(Pic)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>맵 (Maps)</h2>
  
  
  <p>
    맵은 값에 키를 지정합니다.
  </p>
  

  
  <p>
    맵은 반드시 사용하기 전에 <code>make</code> 를 명시해야합니다. (주의: <code>new</code> 가 아닙니다)
  </p>
  

  
  <p>
    <code>make</code> 를 수행하지 않은 <code>nil</code> 에는 값을 할당할 수 없습니다.
  </p>
  

  <div class="source"><!--{{.play prog/maps.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    Lat, Long float64
}

var m map[string]Vertex

func main() {
    m = make(map[string]Vertex)
    m[&#34;Bell Labs&#34;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&#34;Bell Labs&#34;])
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>맵 리터럴 (Map literals)</h2>
  
  
  <p>
    맵 리터럴은 구조체 리터럴과 비슷하지만 <code>key</code> 를 반드시 지정해야 합니다.
  </p>
  

  <div class="source"><!--{{.play prog/map-literals.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    Lat, Long float64
}

var m = map[string]Vertex{
    &#34;Bell Labs&#34;: Vertex{
        40.68433, -74.39967,
    },
    &#34;Google&#34;: Vertex{
        37.42202, -122.08408,
    },
}

func main() {
    fmt.Println(m)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>맵 리터럴 (2)</h2>
  
  
  <p>
    만약 가장 상위의 타입이 타입명이라면 리터럴에서 타입명을 생략해도 됩니다.
  </p>
  

  
  <pre>&#34;Bell Labs&#34;: {40.68433, -74.39967}</pre>
  

  
  <p>
    또는
  </p>
  

  
  <pre>&#34;Bell Labs&#34;: Vertex{40.68433, -74.39967}</pre>
  

  
  <p>
    는 같은 표현입니다.
  </p>
  

  <div class="source"><!--{{.play prog/map-literals-continued.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

type Vertex struct {
    Lat, Long float64
}

var m = map[string]Vertex{
    &#34;Bell Labs&#34;: {40.68433, -74.39967},
    &#34;Google&#34;:    {37.42202, -122.08408},
}

func main() {
    fmt.Println(m)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>맵 다루기 (Mutating Maps)</h2>
  
  
  <p>
    맵 <code>m</code> 의 요소를 삽입하거나 수정하기:
  </p>
  

  
  <pre>m[key] = elem</pre>
  

  
  <p>
    요소 값 가져오기:
  </p>
  

  
  <pre>elem = m[key]</pre>
  

  
  <p>
    요소 지우기:
  </p>
  

  
  <pre>delete(m, key)</pre>
  

  
  <p>
    키의 존재 여부 확인하기:
  </p>
  

  
  <pre>elem, ok = m[key]</pre>
  

  
  <p>
    위의 <code>ok</code> 의 값은 <code>m</code> 에 <code>key</code> 가 존재한다면 <code>true</code> 존재하지 않으면 <code>false</code> , <code>elem</code> 은 타입에 따라 <i>0(zero value)</i> 가 됩니다.
  </p>
  

  
  <p>
    이처럼 <code>map</code> 을 읽을 때, 존재하지 않는 <code>key</code> 의 반환 값은 타입에 맞는 <i>zero value</i> 입니다.
  </p>
  

  <div class="source"><!--{{.play prog/mutating-maps.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    m := make(map[string]int)

    m[&#34;Answer&#34;] = 42
    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])

    m[&#34;Answer&#34;] = 48
    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])

    delete(m, &#34;Answer&#34;)
    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])

    v, ok := m[&#34;Answer&#34;]
    fmt.Println(&#34;The value:&#34;, v, &#34;Present?&#34;, ok)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 맵</h2>
  
  
  <p>
    <code>WordCount</code> 함수를 구현합니다. 이 함수는 <code>s</code>라는 문자열 내에서 각각의 "단어"의 등장 횟수를 나타내는 맵을 반환해야 합니다. <code>wc.Test</code> 함수는 주어진 함수를 이용하여 테스트를 실행한 뒤에 그 성공 여부를 출력해 줍니다.
  </p>
  

  
  <p>
    아마도 다음 링크 (<a href="http://golang.org/pkg/strings/#Fields" target="_blank">strings.Fields</a>)의 내용이 도움이 될 것입니다.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-maps.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;code.google.com/p/go-tour/wc&#34;
)

func WordCount(s string) map[string]int {
    return map[string]int{&#34;x&#34;: 1}
}

func main() {
    wc.Test(WordCount)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>함수 값 (Function values)</h2>
  
  
  <p>
    함수도 값 입니다.
  </p>
  

  
  <p>
    (번역자 : 맨 아래 <code>hypot(3,4)</code> 의 hypot 함수를 Println함수의 인자값 처럼 사용 하고 있습니다.)
  </p>
  

  <div class="source"><!--{{.play prog/function-values.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

func main() {
    hypot := func(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }

    fmt.Println(hypot(3, 4))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>함수 클로져 (Function closures)</h2>
  
  
  <p>
    그리고 함수는 클로져(full closures) 입니다.
  </p>
  

  
  <p>
    코드에서 <code>adder</code> 함수는 클로져(closure)를 반환합니다.
  </p>
  

  
  <p>
    각각의 클로져는 자신만의 <code>sum</code> 변수를 가집니다.
  </p>
  

  <div class="source"><!--{{.play prog/function-closures.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 피보나치 클로져</h2>
  
  
  <p>
    함수를 가지고 놀아봅시다.
  </p>
  

  
  <p>
    <code>fibonacci</code> 함수를 구현합니다. 이 함수는 이어지는 피보나치 수를 반환하는 함수 (클로져)를 반환해야 합니다.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-fibonacci-closure.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
}

func main() {
    f := fibonacci()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(f())
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>스위치 (Switch)</h2>
  
  
  <p>
    다른 일반적인 언어를 아는 분이라면 <code>switch</code> 에 대해서 잘 알 것입니다.
  </p>
  

  
  <p>
    다른 언어와 다른점은 case의 코드 실행을 마치면 알아서 break를 한다는 점입니다.
  </p>
  

  
  <p>
    ( <code>fallthrough</code> 로 끝나는 case는 스스로 break를 하지 않습니다 )
  </p>
  

  <div class="source"><!--{{.play prog/switch.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;runtime&#34;
)

func main() {
    fmt.Print(&#34;Go runs on &#34;)
    switch os := runtime.GOOS; os {
    case &#34;darwin&#34;:
        fmt.Println(&#34;OS X.&#34;)
    case &#34;linux&#34;:
        fmt.Println(&#34;Linux.&#34;)
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf(&#34;%s.&#34;, os)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>스위치 동작 순서</h2>
  
  
  <p>
    스위치의 각 조건은 위에서 아래로 평가합니다. 만약 조건이 참인 case를 찾으면 평가를 마칩니다.
  </p>
  

  
  <p>
    (예를 들어
  </p>
  

  
  <pre>switch i {
case 0:
case f():
}</pre>
  

  
  <p>
    에서 <code>i==0</code> 이라면 <code>f()</code> 는 실행하지 않습니다)
  </p>
  

  <div class="source"><!--{{.play prog/switch-evaluation-order.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func main() {
    fmt.Println(&#34;When&#39;s Saturday?&#34;)
    today := time.Now().Weekday()
    switch time.Saturday {
    case today + 0:
        fmt.Println(&#34;Today.&#34;)
    case today + 1:
        fmt.Println(&#34;Tomorrow.&#34;)
    case today + 2:
        fmt.Println(&#34;In two days.&#34;)
    default:
        fmt.Println(&#34;Too far away.&#34;)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>조건을 생략한 스위치</h2>
  
  
  <p>
    스위치에서 조건을 생략하면 &quot; <code>switch</code> <code>true</code> &quot; 와 같습니다.
  </p>
  

  
  <p>
    만약 긴 if-then-else 를 작성해야 할 때, 이 구조를 사용하면 코드를 깔끔하게 작성할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/switch-with-no-condition.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func main() {
    t := time.Now()
    switch {
    case t.Hour() &lt; 12:
        fmt.Println(&#34;Good morning!&#34;)
    case t.Hour() &lt; 17:
        fmt.Println(&#34;Good afternoon.&#34;)
    default:
        fmt.Println(&#34;Good evening.&#34;)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>심화 연습: 복소수 세제곱근</h2>
  
  
  <p>
    <code>complex64</code> 타입과 <code>complex128</code> 타입을 통해서 Go 언어의 복소수 지원 기능을 알아봅니다. 세제곱근을 얻기 위해서는, 뉴턴의 방법 (Newton&apos;s method)을 적용하여 다음을 반복 수행합니다:
  </p>
  
  <p>
    z = z - (z * z * z - x) / (3 * z * z)
  </p>
  
  <p>
    알고리즘이 잘 동작하는지 확인하기 위해 2의 세제곱근을 구해봅시다. <code>math/cmplx</code> 패키지에는 <a href="http://golang.org/pkg/math/cmplx/#Pow" target="_blank">Pow</a> 함수가 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/advanced-exercise-complex-cube-roots.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func Cbrt(x complex128) complex128 {
}

func main() {
    fmt.Println(Cbrt(2))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide nocode">
	
  <h2>메소드와 인터페이스</h2>
  

</div>

<div class="slide">
	
  <h2>메소드 (Methods)</h2>
  
  
  <p>
    고에는 클래스가 없습니다. 하지만 메소드를 구조체(struct)에 붙일 수 있습니다.
  </p>
  

  
  <p>
    <i>메소드 리시버(method receiver)</i> 는 <code>func</code> 키워드와 메소드의 이름 사이에 인자로 들어갑니다.
  </p>
  

  <div class="source"><!--{{.play prog/methods.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := &amp;Vertex{3, 4}
    fmt.Println(v.Abs())
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>메소드 (2)</h2>
  
  
  <p>
    사실 메소드는 구조체(struct) 뿐 아니라 아무 타입(type)에나 붙일 수 있습니다.
  </p>
  

  
  <p>
    다른 패키지에 있는 타입이나 기본 타입들에 메소드를 붙이는 것은 불가능합니다.
  </p>
  

  <div class="source"><!--{{.play prog/methods-continued.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>포인터 리시버를 가지는 메소드</h2>
  
  
  <p>
    메소드는 이름이 있는 타입 또는 이름이 있는 타입의 포인터와 연결할 수 있습니다.
  </p>
  

  
  <p>
    방금 두 개의 <code>Abs</code> 메소드를 보았는데, 하나는 <code>*Vertex</code> 라는 포인터 타입의 메소드고, 다른 하나는 <code>MyFloat</code> 값 타입의 메소드 입니다.
  </p>
  

  
  <p>
    포인터 리시버를 사용하는 이유는 두 가지 입니다. 첫째, 메소드가 호출될 때 마다 값이 복사되는 것(큰 구조체 타입인 경우 값이 복사되는 것은 비효율적이죠)을 방지하기 위함 입니다. 다른 이유는 메소드에서 리시버 포인터가 가르키는 값을 수정하기 위함 입니다.
  </p>
  

  
  <p>
    <code>*Vertex</code> 타입의 리시버 대신 <code>Vertex</code> 를 사용하도록 메소드 <code>Abs</code> 와 <code>Scale</code> 의 선언부분을 바꿔 보세요.
  </p>
  

  
  <p>
    <code>v</code> 를 <code>Vertex</code> 타입으로 받으면 <code>Scale</code> 메소드가 더 이상 동작하지 않습니다. <code>Scale</code> 은 <code>v</code> 를 바꾸는데, <code>v</code> 가 (포인터가 아닌) 값 타입이기 때문에 <code>Vertex</code> 타입인 복사본에 작업을 하기 때문에 원래의 값은 바뀌지 않습니다.
  </p>
  

  
  <p>
    <code>Abs</code> 의 경우는 다릅니다. 여기서는 <code>v</code> 를 읽기만 하기 때문에, (포인터가 가르키는) 원래의 값이건 복사본이건 상관이 없게 됩니다.
  </p>
  

  <div class="source"><!--{{.play prog/methods-with-pointer-receivers.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := &amp;Vertex{3, 4}
    v.Scale(5)
    fmt.Println(v, v.Abs())
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>인터페이스 (Interface)</h2>
  
  
  <p>
    인터페이스는 메소드의 집합으로 정의됩니다.
  </p>
  

  
  <p>
    그 메소드들의 구현되어 있는 타입의 값은 모두 인터페이스 타입의 값이 될 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/interfaces.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;math&#34;
)

type Abser interface {
    Abs() float64
}

func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}

    a = f  // a MyFloat implements Abser
    a = &amp;v // a *Vertex implements Abser
    a = v  // a Vertex, does NOT
    // implement Abser

    fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>인터페이스 암시적으로 충족됩니다</h2>
  
  
  <p>
    타입이 인터페이스의 메소드들을 구현하면 인터페이스를 구현한 게 됩니다.
  </p>
  

  
  <p>
    <i>이를 위해 명시적으로 선언할 게 없습니다.</i>
  </p>
  

  
  <p>
    암시적 인터페이스는 인터페이스를 정의한 패키지로 부터 구현 패키지를 분리(decouple)해 줍니다. 다른 의존성 또한 없음은 물론입니다.
  </p>
  

  
  <p>
    이 특징은 상세하게 인터페이스를 정의하게 독려합니다. 모든 구현을 찾아 새 인터페이스 이름으로 태그할 필요가 없기 때문입니다.
  </p>
  

  
  <p>
    <a href="http://golang.org/pkg/io/" target="_blank">패키지 io</a>에 <code>Reader</code> 와 <code>Writer</code> 가 정의되어 있습니다. 따로 정의할 필요가 없습니다.
  </p>
  

  <div class="source"><!--{{.play prog/interfaces-are-satisfied-implicitly.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;os&#34;
)

type Reader interface {
    Read(b []byte) (n int, err error)
}

type Writer interface {
    Write(b []byte) (n int, err error)
}

type ReadWriter interface {
    Reader
    Writer
}

func main() {
    var w Writer

    // os.Stdout implements Writer
    w = os.Stdout

    fmt.Fprintf(w, &#34;hello, writer\n&#34;)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>에러(error)</h2>
  
  
  <p>
    에러 문장(string)으로 자신을 표현할 수 있는 것은 모두 에러입니다. 이 아이디어는 문자열(string)을 반환하는 하나의 메소드 <code>Error</code> 로 구성된 내장 인터페이스 타입 <code>error</code> 에서 나왔습니다.
  </p>
  

  
  <pre>type error interface {
	Error() string
}</pre>
  

  
  <p>
    <code>fmt</code> 패키지의 다양한 출력 루틴들은 <code>error</code> 의 출력을 요청받았을 때 자동으로 이 메소드를 호출합니다.
  </p>
  

  <div class="source"><!--{{.play prog/errors.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

type MyError struct {
    When time.Time
    What string
}

func (e *MyError) Error() string {
    return fmt.Sprintf(&#34;at %v, %s&#34;,
        e.When, e.What)
}

func run() error {
    return &amp;MyError{
        time.Now(),
        &#34;it didn&#39;t work&#34;,
    }
}

func main() {
    if err := run(); err != nil {
        fmt.Println(err)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 에러</h2>
  
  
  <p>
    당신의 <code>Sqrt</code> 함수를 이전 연습에서 복사하고 <code>error</code> 값을 반환하도록 수정하십시오.
  </p>
  

  
  <p>
    <code>Sqrt</code> 함수는 복소수를 지원하지 않기 때문에, 음수가 주어지면 <code>nil</code> 이 아닌 에러 값을 반환해야 합니다.
  </p>
  

  
  <p>
    새로운 타입을 만드십시오.
  </p>
  

  
  <pre>type ErrNegativeSqrt float64</pre>
  

  
  <p>
    and make it an <code>error</code> by giving it a


    그리고 아래 메소드를 구현함으로써 그 타입이 <code>error</code> 가 되게 하십시오.
  </p>
  

  
  <pre>func (e ErrNegativeSqrt) Error() string</pre>
  

  
  <p>
    이는 <code>ErrNegativeSqrt(-2).Error()</code> 가 <code>&quot;cannot Sqrt negative number: -2&quot;</code> 를 반환하는 그러한 메소드입니다.
  </p>
  

  
  <p>
    <b>Note:</b> <code>Error</code> 메소드 내에서 <code>fmt.Print(e)</code> 를 호출하면 이 프로그램을 무한루프에 빠질 것입니다. <code>e</code> 를 바꿈으로써 이 문제를 피할 수 있습니다. 왜 그럴까요?
  </p>
  

  
  <p>
    음수가 주어졌을 때 <code>ErrNegativeSqrt</code> 값을 반환하도록 당신의 <code>Sqrt</code> 함수를 바꾸십시오.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-errors.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
)

func Sqrt(f float64) (float64, error) {
    return 0, nil
}

func main() {
    fmt.Println(Sqrt(2))
    fmt.Println(Sqrt(-2))
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>웹 서버</h2>
  
  
  <p>
    <a href="http://golang.org/pkg/net/http/" target="_blank">Package http</a> 는 <code>http.Handler</code> 를 구현한 어떠 값을 사용하여 HTTP 요청(requests)을 제공합니다.
  </p>
  

  
  <pre>package http

type Handler interface {
	ServeHTTP(w ResponseWriter, r *Request)
}</pre>
  

  
  <p>
    이 예제에서, <code>Hello</code> 라는 타입은 <code>http.Handler</code> 를 구현합니다.
  </p>
  

  
  <p>
    이 코드를 로컬에서 실행하고, <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> 에 접속해보세요.
  </p>
  

  <div class="source"><!--{{.play prog/web-servers.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;net/http&#34;
)

type Hello struct{}

func (h Hello) ServeHTTP(
    w http.ResponseWriter,
    r *http.Request) {
    fmt.Fprint(w, &#34;Hello!&#34;)
}

func main() {
    var h Hello
    http.ListenAndServe(&#34;localhost:4000&#34;, h)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: HTTP 핸들러</h2>
  
  
  <p>
    아래 나오는 타입을 구현하고 그 타입의 ServeHTTP 메소드를 정의하십시오. 그 메소드를 당신의 웹 서버에서 특정 경로를 처리할 수 있도록 등록하십시오.
  </p>
  

  
  <pre>type String string

type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
  

  
  <p>
    예컨대, 당신은 아래와 같이 핸들러를 등록할 수 있어야 합니다.
  </p>
  

  
  <pre>http.Handle(&#34;/string&#34;, String(&#34;I&#39;m a frayed knot.&#34;))
http.Handle(&#34;/struct&#34;, &amp;Struct{&#34;Hello&#34;, &#34;:&#34;, &#34;Gophers!&#34;})</pre>
  

  <div class="source"><!--{{.play prog/exercise-http-handlers.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;net/http&#34;
)

func main() {
    // your http.Handle calls here
    http.ListenAndServe(&#34;localhost:4000&#34;, nil)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>이미지</h2>
  
  
  <p>
    <a href="http://golang.org/pkg/image/#Image" target="_blank">Package image</a> 는 <code>Image</code> 인터페이스를 정의합니다.
  </p>
  

  
  <pre>package image

type Image interface {
	ColorModel() color.Model
	Bounds() Rectangle
	At(x, y int) color.Color
}</pre>
  

  
  <p>
    (모든 세부사항에 대한 것은 <a href="http://golang.org/pkg/image/#Image" target="_blank">이 문서</a> 를 참고하십시오.)
  </p>
  

  
  <p>
    또한, <code>color.Color</code> 와 <code>color.Model</code> 는 인터페이스이지만, 미리 정의된 구현체인 <code>color.RGBA</code> 와 <code>color.RGBAModel</code> 을 사용함으로써 그 인터페이스를 무시할 수 있습니다.
  </p>
  

  <div class="source"><!--{{.play prog/images.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;image&#34;
)

func main() {
    m := image.NewRGBA(image.Rect(0, 0, 100, 100))
    fmt.Println(m.Bounds())
    fmt.Println(m.At(0, 0).RGBA())
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 이미지</h2>
  
  
  <p>
    이전의 연습에서 당신이 작성한 그림 생성기를 기억하십니까? 다른 생성기를 만들어봅시다. 하지만 이번에는 데이터의 슬라이스 대신에 <code>image.Image</code> 의 구현체를 반환할 것입니다.
  </p>
  

  
  <p>
    당신 자신의 <code>Image</code> 타입을 정의하시고, <a href="http://golang.org/pkg/image/#Image" target="_blank">필수 함수들</a> 을 구현하신 다음, <code>pic.ShowImage</code> 를 호출하십시오.
  </p>
  

  
  <p>
    <code>Bounds</code> 는 <code>image.Rect(0, 0, w, h)</code> 와 같은 <code>image.Rectangle</code> 을 반환해야 합니다.
  </p>
  

  
  <p>
    <code>ColorModel</code> 은 <code>color.RGBAModel</code> 을 반환해야 합니다.
  </p>
  

  
  <p>
    <code>At</code> 은 하나의 컬러를 반환해야 합니다; 지난 그림 생성기에서 값 <code>v</code> 는 <code>color.RGBA{v, v, 255, 255}</code> 와 같습니다.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-images.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;code.google.com/p/go-tour/pic&#34;
    &#34;image&#34;
)

type Image struct{}

func main() {
    m := Image{}
    pic.ShowImage(m)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: Rot13 Reader</h2>
  
  
  <p>
    어떤 식으로든 스트림을 수정하여 다른 <code>io.Reader</code> 를 감싸는 <a href="http://golang.org/pkg/io/#Reader" target="_blank">io.Reader</a> 는 흔한 패턴입니다.
  </p>
  

  
  <p>
    예컨대, <a href="http://golang.org/pkg/compress/gzip/#NewReader" target="_blank">gzip.NewReader</a> 함수는 <code>io.Reader</code> (gzip으로 압축된 데이터의 스트림) 를 가지고, <code>io.Reader</code> (압축 해제된 데이터의 스트림) 를 구현한 `*gzip.Reader`를 반환합니다.
  </p>
  

  
  <p>
    <a href="http://en.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a> 치환 암호화를 모든 알파벳 문자에 적용함으로써 스트림을 수정하며 <code>io.Reader</code> 를 구현하고 <code>io.Reader</code> 로 부터 읽는 <code>rot13Reader</code> 를 구현하십시오.
  </p>
  

  
  <p>
    <code>rot13Reader</code> 타입은 당신을 위해 제공됩니다. 이 타입의 <code>Read</code> 함수를 구현함으로써 <code>io.Reader</code> 을 만들어 보십시오.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-rot-reader.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;io&#34;
    &#34;os&#34;
    &#34;strings&#34;
)

type rot13Reader struct {
    r io.Reader
}

func main() {
    s := strings.NewReader(
        &#34;Lbh penpxrq gur pbqr!&#34;)
    r := rot13Reader{s}
    io.Copy(os.Stdout, &amp;r)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide nocode">
	
  <h2>동시성</h2>
  

</div>

<div class="slide">
	
  <h2>고루틴(Goroutines)</h2>
  
  
  <p>
    _고루틴_은 Go 런타임에 의해 관리되는 경량 쓰레드입니다.
  </p>
  

  
  <pre>go f(x, y, z)</pre>
  

  
  <p>
    위의 코드는 새로운 고루틴을 시작시킵니다.
  </p>
  

  
  <pre>f(x, y, z)</pre>
  

  
  <p>
    현재의 고루틴에서 <code>f</code> , <code>x</code> , <code>y</code> , <code>z</code> 가 평가(evaluation)되고, 새로운 고루틴에서 <code>f</code> 가 수행(execution)됩니다.
  </p>
  

  
  <p>
    고루틴은 동일한 주소 공간에서 실행되므로, 공유되는 자원으로의 접근은 반드시 동기화 되어야 합니다. <code>[[http://golang.org/pkg/sync/][sync]]</code> 패키지가 이를 위해 유용한 기본 기능을 제공합니다. Go 에서는 그외에도 다양한 기본 기능을 제공하니 크게 필요치 않을 테지만요. (다음 슬라이드를 보세요.) 
  </p>
  

  <div class="source"><!--{{.play prog/goroutines.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func say(s string) {
    for i := 0; i &lt; 5; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    }
}

func main() {
    go say(&#34;world&#34;)
    say(&#34;hello&#34;)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>채널(Channels)</h2>
  
  
  <p>
    채널은 채널 연산자 <code>&lt;-</code> 를 이용해 값을 주고 받을 수 있는, 타입이 존재하는 파이프입니다.
  </p>
  

  
  <pre>ch &lt;- v    // v 를 ch로 보냅니다.
v := &lt;-ch  // ch로부터 값을 받아서
           // v 로 넘깁니다.</pre>
  

  
  <p>
    (데이터가 화살표 방향에 따라 흐릅니다.)
  </p>
  

  
  <p>
    맵이나 슬라이스처럼, 채널은 사용되기 전에 생성되어야 합니다:
  </p>
  

  
  <pre>ch := make(chan int)</pre>
  

  
  <p>
    기본적으로, 송/수신은 상대편이 준비될 때까지 블록됩니다. 이런 특성이 고루틴이 명시적인 락이나 조건 없이도 동기화 될 수 있도록 돕습니다.
  </p>
  

  <div class="source"><!--{{.play prog/channels.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func sum(a []int, c chan int) {
    sum := 0
    for _, v := range a {
        sum += v
    }
    c &lt;- sum // send sum to c
}

func main() {
    a := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(a[:len(a)/2], c)
    go sum(a[len(a)/2:], c)
    x, y := &lt;-c, &lt;-c // receive from c

    fmt.Println(x, y, x+y)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>버퍼링되는 채널</h2>
  
  
  <p>
    채널은 _버퍼링_될 수 있습니다. <code>make</code> 에 두번째 인자로 버퍼 용량을 넣음으로써 해당 용량만큼 버퍼링되는 채널을 생성할 수 있습니다:
  </p>
  

  
  <pre>ch := make(chan int, 100)</pre>
  

  
  <p>
    버퍼링되는 채널로의 송신은 버퍼가 꽉 찰 때까지 블록됩니다. 수신측은 버퍼가 빌 때 블록됩니다.
  </p>
  

  
  <p>
    예제를 수정해서 버퍼를 넘치게 해보고 어떻게 동작하는지 확인해 보세요.
  </p>
  

  <div class="source"><!--{{.play prog/buffered-channels.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func main() {
    c := make(chan int, 2)
    c &lt;- 1
    c &lt;- 2
    fmt.Println(&lt;-c)
    fmt.Println(&lt;-c)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>Range와 Close</h2>
  
  
  <p>
    데이터 송신측은 더이상 보낼 값이 없다는 것을 알리기 위해 채널을 <code>close</code> 할 수 있습니다. 수신측은 다음과 같이 수신 코드에 두번째 인자를 줌으로써 채널이 닫혔는지 테스트 할 수 있습니다.
  </p>
  

  
  <pre>v, ok := &lt;-ch</pre>
  

  
  <p>
    채널이 이미 닫혔고 더이상 받을 값이 없다면 <code>ok</code> 는 <code>false</code> 가 됩니다.
  </p>
  

  
  <p>
    <code>for i := range c</code> 반복문은 채널이 닫힐 때까지 계속해서 값을 받습니다.
  </p>
  

  
  <p>
    <b>주의:</b> 송신측만 채널을 닫을 수 있습니다. 수신측에선 불가능합니다. 이미 닫힌 채널에 데이터를 보내면 패닉이 일어납니다.
  </p>
  

  
  <p>
    <b>또하나의 주의</b>: 채널은 파일과 다릅니다; 항상 닫을 필요는 없습니다. 채널을 닫는 행위는 오로지 수신측에게 더이상 보낼 값이 없다고 말해야 할때만 행해지면 됩니다. <code>range</code> 루프를 종료시켜야 할 때처럼요.
  </p>
  

  <div class="source"><!--{{.play prog/range-and-close.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
)

func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i &lt; n; i++ {
        c &lt;- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    for i := range c {
        fmt.Println(i)
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>셀렉트(Select)</h2>
  
  
  <p>
    <code>select</code> 구문은 고루틴이 다수의 통신 동작으로부터 수행 준비를 기다릴 수 있게 합니다.
  </p>
  

  
  <p>
    <code>select</code> 는 <code>case</code> 구문으로 받는 통신 동작들 중 하나가 수행될 수 있을 때까지 수행을 블록합니다. 다수의 채널이 동시에 준비되면 그 중 하나를 무작위로 선택합니다.
  </p>
  

  <div class="source"><!--{{.play prog/select.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;fmt&#34;

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &lt;- x:
            x, y = y, x+y
        case &lt;-quit:
            fmt.Println(&#34;quit&#34;)
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &lt; 10; i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }()
    fibonacci(c, quit)
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>셀렉트의 디폴트(default) 케이스</h2>
  
  
  <p>
    <code>select</code> 의 <code>default</code> 케이스는 현재 수행 준비가 완료된 케이스가 없을 때 수행됩니다.
  </p>
  

  
  <p>
    블로킹 없이(비동기적인) 송/수신을 하고자 할 때 <code>default</code> 케이스를 사용하세요.
  </p>
  

  
  <pre>select {
case i := &lt;-c:
	// i를 사용
default:
	// c로부터의 수신은 블록된 상태
}</pre>
  

  <div class="source"><!--{{.play prog/default-selection.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func main() {
    tick := time.Tick(1e8)
    boom := time.After(5e8)
    for {
        select {
        case &lt;-tick:
            fmt.Println(&#34;tick.&#34;)
        case &lt;-boom:
            fmt.Println(&#34;BOOM!&#34;)
            return
        default:
            fmt.Println(&#34;    .&#34;)
            time.Sleep(5e7)
        }
    }
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide nocode">
	
  <h2>연습: 동등한 이진 트리</h2>
  
  
  <p>
    노드(leaf)들에 있는 값들의 정렬 순열는 같지만 생김새가 다른 이진트리가 있을 수 있습니다. 예를들어, 다음 그림의 두 이진 트리를 정렬 순열는 1, 1, 2, 3, 5, 8, 13 으로 같습니다.
  </p>
  

  
  <p>
    대부분의 프로그래밍 언어에서 두 이진 트리가 같은 순열인지를 검사하는 함수의 구현은 복잡합니다. 이제 고의 동시성과 채널을 사용한 단순한 방법으로 해결해 봅시다.
  </p>
  

  
  <p>
    이 예제는 다음의 <code>Tree</code> 구조체가 정의된 <code>tree</code> 패키지를 사용합니다.
  </p>
  

  
  <pre>type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}</pre>
  


</div>

<div class="slide">
	
  <h2>연습: 동등한 이진 트리</h2>
  
  
  <p>
    <b>1.</b> <code>Walk</code> 함수를 구현하세요.
  </p>
  

  
  <p>
    <b>2.</b> <code>Walk</code> 함수를 테스트 해 보세요.
  </p>
  

  
  <p>
    함수 `tree.New(k)`는 <code>k</code> , <code>2k</code> , <code>3k</code> , ..., <code>10k</code> 의 값을 가지는, 무작위로 구성된 이진트리를 만들어 냅니다.
  </p>
  

  
  <p>
    채널 <code>ch</code> 를 만들고, 작성한 <code>Walk</code> 함수의 인자로 넣어 줍니다.
  </p>
  

  
  <pre>go Walk(tree.New(1), ch)</pre>
  

  
  <p>
    이제 채널에서 10개의 값을 읽어 봅니다. 읽힌 값은 1, 2, 3, ..., 10 이어야 합니다.
  </p>
  

  
  <p>
    <b>3.</b> <code>Walk</code> 함수를 사용해 두 트리 <code>t1</code> 과 <code>t2</code> 이 값은 값들을 가지고 있는지 비교하는 <code>Same</code> 함수를 구현해 보세요.
  </p>
  

  
  <p>
    <b>4.</b> <code>Same</code> 함수를 테스트 해 보세요.
  </p>
  

  
  <p>
    `Same(tree.New(1),`tree.New(1))`의 수행결과는 true, `Same(tree.New(1),`tree.New(2))`의 수행 결과는 false 이어야 합니다.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-equivalent-binary-trees.go}}
--><pre style="display: none"></pre><pre>package main

import &#34;code.google.com/p/go-tour/tree&#34;

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int)

// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool

func main() {
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide">
	
  <h2>연습: 웹 크롤러</h2>
  
  
  <p>
    이 연습에서는 고의 동시성 기능을 사용해 웹 크롤러를 병렬화 해 볼 것입니다.
  </p>
  

  
  <p>
    <code>Crawl</code> 함수를 고쳐서, 같은 URL을 두번 가져오는 중복을 피하면서 URL들을 병렬로 패치하게 고쳐보세요.
  </p>
  

  <div class="source"><!--{{.play prog/exercise-web-crawler.go}}
--><pre style="display: none"></pre><pre>package main

import (
    &#34;fmt&#34;
)

type Fetcher interface {
    // Fetch returns the body of URL and
    // a slice of URLs found on that page.
    Fetch(url string) (body string, urls []string, err error)
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
    // TODO: Fetch URLs in parallel.
    // TODO: Don&#39;t fetch the same URL twice.
    // This implementation doesn&#39;t do either:
    if depth &lt;= 0 {
        return
    }
    body, urls, err := fetcher.Fetch(url)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf(&#34;found: %s %q\n&#34;, url, body)
    for _, u := range urls {
        Crawl(u, depth-1, fetcher)
    }
    return
}

func main() {
    Crawl(&#34;http://golang.org/&#34;, 4, fetcher)
}

// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
    body string
    urls []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, error) {
    if res, ok := (*f)[url]; ok {
        return res.body, res.urls, nil
    }
    return &#34;&#34;, nil, fmt.Errorf(&#34;not found: %s&#34;, url)
}

// fetcher is a populated fakeFetcher.
var fetcher = &amp;fakeFetcher{
    &#34;http://golang.org/&#34;: &amp;fakeResult{
        &#34;The Go Programming Language&#34;,
        []string{
            &#34;http://golang.org/pkg/&#34;,
            &#34;http://golang.org/cmd/&#34;,
        },
    },
    &#34;http://golang.org/pkg/&#34;: &amp;fakeResult{
        &#34;Packages&#34;,
        []string{
            &#34;http://golang.org/&#34;,
            &#34;http://golang.org/cmd/&#34;,
            &#34;http://golang.org/pkg/fmt/&#34;,
            &#34;http://golang.org/pkg/os/&#34;,
        },
    },
    &#34;http://golang.org/pkg/fmt/&#34;: &amp;fakeResult{
        &#34;Package fmt&#34;,
        []string{
            &#34;http://golang.org/&#34;,
            &#34;http://golang.org/pkg/&#34;,
        },
    },
    &#34;http://golang.org/pkg/os/&#34;: &amp;fakeResult{
        &#34;Package os&#34;,
        []string{
            &#34;http://golang.org/&#34;,
            &#34;http://golang.org/pkg/&#34;,
        },
    },
}
</pre><pre style="display: none"></pre></div>


</div>

<div class="slide nocode">
	
  <h2>더 살펴볼 곳 들...</h2>
  
  
  <p>
    우선 <a href="http://golang.org/doc/" target="_blank">Go 문서</a> 사이트에서 시작하는 것이 좋습니다. 여기에서 레퍼런스, 튜토리얼, 비디오 등의 자료를 볼 수 있습니다.
  </p>
  

  
  <p>
    고 코드를 구성하기와 고로 작업하는 방법을 배우려면, <a href="http://www.youtube.com/watch?v=XCsL89YtqCs" target="_blank">이 스크린캐스트</a>를 보거나, <a href="http://golang.org/doc/code.html" target="_blank">고 코드 작성 방법</a>를 읽어 보세요.
  </p>
  

  
  <p>
    표준 라이브러리에 대한 도움이 필요하면, <a href="http://golang.org/pkg/" target="_blank">패키지 레퍼런스</a>를 살펴보세요. 고 언어 자체에 대해서는 <a href="http://golang.org/ref/spec" target="_blank">언어 스펙</a>이 도움이 되며, 아마 꽤 쉽게 스펙문서를 읽을 수 있음에 놀라게 될 것입니다.
  </p>
  

  
  <p>
    더 나아가 고의 동시성(concurrency) 모델을 살펴보려면 코드워크, <a href="http://golang.org/doc/codewalk/sharemem/" target="_blank">통신으로 메모리 공유하기</a>를 보세요.
  </p>
  

  
  <p>
    코드워크, <a href="http://golang.org/doc/codewalk/functions/" target="_blank">First Class Functions in Go</a>에서는 고의 함수 타입에 관련된 흥미로운 관점을 제공합니다.
  </p>
  

  
  <p>
    공식 블로그, <a href="http://blog.golang.org/" target="_blank">Go </a>에는 유익한 기사들이 많이 있습니다.
  </p>
  

  
  <p>
    공식 사이트 <a href="http://golang.org" target="_blank">golang.org</a>를 방문해 더 살펴보세요.
  </p>
  

  
  <p>
    번역: <a href="https://developers.google.com/groups/chapter/112714242728066184635/" target="_blank">한국 Go 언어 커뮤니티(GDG Korea Golang)</a>
  </p>
  


</div>


</div>

<div id="workspace">
	<div class="controls">
		<div><a id="run" href="#run" title="Compile and Run">Run</a><a href="#more" id="more" title="Options">▼</a></div>
		<ul class="more">
			<li><a href="#" id="reset">Reset Slide</a></li>
			<li><a href="#" id="format">Format Source Code</a></li>
			<li><a href="#" id="kill" class="localMode">Kill Program</a></li>
			<li><hr></li>
			<li><a href="#" id="togglesyntax">Syntax-Highlighting: off</a></li>
			<li><a href="#" id="togglelineno">Line-Numbers: on</a></li>
		</ul>
	</div>

	<div id="workspace-top">
		<div id="workspace-editor">
			<textarea id="editor" spellcheck="false"></textarea>
		</div>
	</div>

	<div id="workspace-bottom">
		<div id="output"></div>
	</div>
</div>
</div>

</body>
</html>
