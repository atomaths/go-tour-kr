
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>A Tour of Go</title>


<script src="/static/jquery.js"></script>


<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/lib/go.js"></script>


<link rel="stylesheet" href="static/tour.css">
<script src="/static/lang.js"></script>
<script src="/static/tour.js"></script>

</head>
<body>
	<div id="wrap">
		<div id="header">
			<div id="slidenum">1</div>
				<a href="#toc" id="tocbtn" title="Table of Contents"></a>
				<h1>A Tour of Go</h1>
			</div>

<div id="slides" class="slides">


<div class="slide">
	
  <h2>Hello, 안녕</h2>
  
  
  <p>
    <a href="http://golang.org" target="_blank">Go 프로그래밍 언어</a> 투어에 오신 것을 환영합니다.
  </p>
  

  
  <p>
    이 투어는 3개의 섹션으로 되어 있고, 각 섹션의 마지막 부분에는 좀더 완벽한 이해를 돕기 위해 연습문제가 준비되어 있습니다.
  </p>
  

  
  <p>
    지금 Run 버튼을 클릭해보거나 키보드에서 Shift-Enter 키를 눌러보세요. 옆의 Go 소스가 컴파일되고 실행될 겁니다. 실행 결과는 코드 밑에 표시됩니다.
  </p>
  

  
  <p>
    이 투어에 있는 많은 예제 프로그램들은 Go가 다른 언어들과 어떤 차이점이 있는지 보여줄 것이고, 여러분이 Go를 배우는데 출발점이 될 것입니다.
  </p>
  

  
  <p>
    소스를 수정하고 다시 한번 실행해보세요.
  </p>
  

  
  <p>
    이제 다음으로 넘어갈 준비가 되었으면, Next 버튼을 클릭하거나 PageDown 키를 누르세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    fmt.Println(&#34;Hello, 안녕&#34;)</span>
<span num="7">}</span>
</pre>


</div>


</div>

<div class="slide nocode">
	
  <h2>Go local</h2>
  
  
  <p>
    이 투어는 다른 나라 언어로도 이용할 수 있습니다:
  </p>
  

  <ul>
  
    <li><a href="http://go-tour-br.appspot.com/" target="_blank">Brazilian Portuguese — Português do Brasil</a></li>
  
    <li><a href="http://go-tour-he.appspot.com/" target="_blank">Hebrew — עִבְרִית</a></li>
  
    <li><a href="http://go-tour-zh.appspot.com/" target="_blank">Chinese — 普通话</a></li>
  
    <li><a href="http://go-tour-jp.appspot.com/" target="_blank">Japanese — 日本語</a></li>
  
    <li><a href="http://go-tour-kr.appspot.com/" target="_blank">Korean — 한국어</a></li>
  
  </ul>

  
  <p>
    계속 하시려면 Next 버튼을 클릭하거나 PageDown 키를 누르세요.
  </p>
  


</div>

<div class="slide nocode">
	
  <h2>Go offline</h2>
  
  
  <p>
    Go Tour는 인터넷 연결없이 stand-alone 프로그램으로도 사용할 수 있습니다.
  </p>
  

  
  <p>
    stand-alone으로 Go Tour를 이용하면 예제 코드들이 로컬 머신에서 빌드되고 실행되기 때문에 보다 빠릅니다. 그리고 웹버전에는 가능하지 않은 추가적인 연습문제들을 포함하고 있습니다.
  </p>
  

  
  <p>
    이 투어를 로컬에서 실행하기 위해 먼저 <a href="http://golang.org/doc/install/" target="_blank">Go를 설치</a> 하고, <a href="http://code.google.com/p/go-tour/" target="_blank">gotour</a>를 설치하기 위해 <a href="http://golang.org/cmd/go/" target="_blank">go get</a>을 명령을 이용하면 됩니다.
  </p>
  

  
  <pre>go get code.google.com/p/go-tour/gotour</pre>
  

  
  <p>
    그리고 위 결과로 생긴 <code>gotour</code> 를 실행하세요.
  </p>
  

  
  <p>
    오프라인 모드를 사용하지 않고 계속 진행하려면, &#34;next&#34; 버튼이나 PageDown 키를 누르세요.
  </p>
  

  
  <p>
    <i>(언제든 &#34;index&#34; 버튼을 누르면 원하는 특별한 챕터로 이동할 수 있습니다.)</i>
  </p>
  


</div>

<div class="slide">
	
  <h2>패키지(Packages)</h2>
  
  
  <p>
    모든 Go 프로그램은 패키지로 구성되어 있습니다.
  </p>
  

  
  <p>
    프로그램은 <code>main</code> 패키지에서부터 실행을 시작합니다.
  </p>
  

  
  <p>
    이 프로그램은 <code>&#34;fmt&#34;</code> 와 <code>&#34;math&#34;</code> 패키지를 import 해서 사용하고 있습니다.
  </p>
  

  
  <p>
    패키지 이름은 디렉토리 경로의 마지막 이름을 사용하는 것이 규칙입니다. 
  </p>
  

  
  <p>
    예를 들어 <code>&#34;path/filepath&#34;</code> 를 사용한다면 패키지명은 <code>filepath</code> 입니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(&#34;Happy&#34;, math.Pi, &#34;Day&#34;)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>임포트 (Imports)</h2>
  
  
  <p>
    이 코드에서는 여러개의 <code>&#34;package&#34;</code> 를 소괄호로 감싸서 import를 표현합니다. 아래와 같이 import 문장을 여러번 사용할 수 도 있습니다.
  </p>
  

  
  <pre>import &#34;fmt&#34;
import &#34;math&#34;</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Printf(&#34;Now you have %g problems.&#34;,</span>
<span num="10">        math.Nextafter(2, 3))</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>익스포트 (Exported names)</h2>
  
  
  <p>
    패키지를 Import 하면 패키지가 외부로 export 한 것들(메서드나 변수, 상수 등)에 접근할 수 있습니다.
  </p>
  

  
  <p>
    Go에서는 첫 문자가 대문자로 시작하면 그 패키지를 사용하는 곳에서 접근할 수 있는 exported name이 됩니다.
  </p>
  

  
  <p>
    예를 들어 <code>Foo</code> 와 <code>FOO</code> 는 외부에서 참조할 수 있지만 <code>foo</code> 는 참조 할 수 없습니다.
  </p>
  

  
  <p>
    예제를 실행해보세요. 에러가 발생한다면 <code>math.pi</code> 를 <code>math.Pi</code> 로 변경 해보세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(math.pi)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>함수 (1)</h2>
  
  
  <p>
    함수는 매개변수(인자)를 가질 수 있습니다.
  </p>
  

  
  <p>
    예를 들어 <code>add</code> 라는 함수는 두개의 <code>int</code> 타입 매개변수를 받습니다.
  </p>
  

  
  <p>
    C, C++, Java 언어와 다르게 매개변수의 타입은 변수명 <i>뒤에</i> 명시합니다.
  </p>
  

  
  <p>
    (타입을 왜 변수명 뒤에 명시하는지에 대한 자세한 내용은 <a href="http://golang.org/doc/articles/gos_declaration_syntax.html" target="_blank">Go&#39;s declaration syntax</a>를 참고하시기 바랍니다. 간단히 설명하면 코드를 왼쪽에서 오른쪽으로 읽을 때 자연스럽게 읽기 위해서 입니다.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func add(x int, y int) int {</span>
<span num="6">    return x &#43; y</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">func main() {</span>
<span num="10">    fmt.Println(add(42, 13))</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>함수 (2)</h2>
  
  
  <p>
    두 개 이상의 매개변수가 같은 타입(type)일 때, 같은 타입을 취하는 마지막 매개변수에만 타입을 명시하고 나머지는 생략할 수 있습니다.
  </p>
  

  
  <p>
    예를 들어
  </p>
  

  
  <pre>x int, y int</pre>
  

  
  <p>
    과 같은 문장은 아래와 같이 표현할 수 있습니다.
  </p>
  

  
  <pre>x, y</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func add(x, y int) int {</span>
<span num="6">    return x &#43; y</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">func main() {</span>
<span num="10">    fmt.Println(add(42, 13))</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>여러 개의 결과 (Multiple results)</h2>
  
  
  <p>
    하나의 함수는 여러 개의 결과를 반환할 수 있습니다.
  </p>
  

  
  <p>
    예제 코드에서의 함수는 두개의 문자열을 반환합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func swap(x, y string) (string, string) {</span>
<span num="6">    return y, x</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">func main() {</span>
<span num="10">    a, b := swap(&#34;hello&#34;, &#34;world&#34;)</span>
<span num="11">    fmt.Println(a, b)</span>
<span num="12">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>이름이 정해진 결과 (Named results)</h2>
  
  
  <p>
    함수는 매개변수를 취합니다. Go에서 함수는 여러 개의 결과를 반환할 수 있습니다. 반환 값에 이름을 부여하면 변수처럼 사용할 수도 있습니다.
  </p>
  

  
  <p>
    결과에 이름을 붙히면, 반환 값을 지정하지 않은 <code>return</code> 문장으로 결과의 현재 값을 알아서 반환합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func split(sum int) (x, y int) {</span>
<span num="6">    x = sum * 4 / 9</span>
<span num="7">    y = sum - x</span>
<span num="8">    return</span>
<span num="9">}</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    fmt.Println(split(17))</span>
<span num="13">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>변수 (Variables)</h2>
  
  
  <p>
    변수를 선언을 위해 <code>var</code> 을 사용합니다.
  </p>
  

  
  <p>
    함수의 매개변수처럼 타입은 문장 끝에 명시합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">var x, y, z int</span>
<span num="6">var c, python, java bool</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(x, y, z, c, python, java)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>변수의 초기화</h2>
  
  
  <p>
    변수 선언과 함께 변수 각각을 초기화를 할 수 있습니다.
  </p>
  

  
  <p>
    초기화를 하는 경우 타입(type)을 생략할 수 있습니다. 변수는 초기화 하고자 하는 값에 따라 타입이 결정됩니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">var x, y, z int = 1, 2, 3</span>
<span num="6">var c, python, java = true, false, &#34;no!&#34;</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(x, y, z, c, python, java)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>변수의 짧은 선언</h2>
  
  
  <p>
    함수 내에서 <code>:=</code> 을 사용하면 <code>var</code> 과 명시적인 타입(e.g. int, bool) 을 생략할 수 있습니다.
  </p>
  

  
  <p>
    (그러나 함수 밖에서는 <code>:=</code> 선언을 사용할 수 없습니다.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    var x, y, z int = 1, 2, 3</span>
<span num="7">    c, python, java := true, false, &#34;no!&#34;</span>
<span num="8"></span>
<span num="9">    fmt.Println(x, y, z, c, python, java)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>상수 (Constants)</h2>
  
  
  <p>
    상수는 <code>const</code> 키워드와 함께 변수처럼 선언합니다.
  </p>
  

  
  <p>
    상수는 문자(character), 문자열(string), 부울(boolean) 등(values)일 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">const Pi = 3.14</span>
<span num="6"></span>
<span num="7">func main() {</span>
<span num="8">    const World = &#34;안녕&#34;</span>
<span num="9">    fmt.Println(&#34;Hello&#34;, World)</span>
<span num="10">    fmt.Println(&#34;Happy&#34;, Pi, &#34;Day&#34;)</span>
<span num="11"></span>
<span num="12">    const Truth = true</span>
<span num="13">    fmt.Println(&#34;Go rules?&#34;, Truth)</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>숫자형 상수 (Numeric Constants)</h2>
  
  
  <p>
    숫자형 상수는 <i>정밀한 값(values)</i> 을 표현할 수 있습니다.
  </p>
  

  
  <p>
    타입을 지정하지 않은 상수는 문맥(context)에 따라 타입을 가지게 됩니다.
  </p>
  

  
  <p>
    코드를 통해 <code>needInt(Big)</code> 는 어떤 결과를 출력할지 실험해보세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">const (</span>
<span num="6">    Big   = 1 &lt;&lt; 100</span>
<span num="7">    Small = Big &gt;&gt; 99</span>
<span num="8">)</span>
<span num="9"></span>
<span num="10">func needInt(x int) int { return x*10 &#43; 1 }</span>
<span num="11">func needFloat(x float64) float64 {</span>
<span num="12">    return x * 0.1</span>
<span num="13">}</span>
<span num="14"></span>
<span num="15">func main() {</span>
<span num="16">    fmt.Println(needInt(Small))</span>
<span num="17">    fmt.Println(needFloat(Small))</span>
<span num="18">    fmt.Println(needFloat(Big))</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>For (반복문 for)</h2>
  
  
  <p>
    Go 언어는 반복문이 <code>for</code> 밖에 없습니다.
  </p>
  

  
  <p>
    기본적인 <code>for</code> 반복문은 C와 Java 언어와 거의 유사합니다. 다른점은 소괄호 ( )가 필요하지 않다는 것입니다.
  </p>
  

  
  <p>
    하지만 실행문을 위한 중괄호 { } 는 필요합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    sum := 0</span>
<span num="7">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="8">        sum &#43;= i</span>
<span num="9">    }</span>
<span num="10">    fmt.Println(sum)</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>For (2)</h2>
  
  
  <p>
    C와 Java에서 처럼 전.후 처리를 제외하고 조건문만 표현할 수도 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    sum := 1</span>
<span num="7">    for sum &lt; 1000 {</span>
<span num="8">        sum &#43;= sum</span>
<span num="9">    }</span>
<span num="10">    fmt.Println(sum)</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Go에서 &#34;While&#34; 사용하기</h2>
  
  
  <p>
    이전의 예제에서 처럼 조건문만 표시하면 C언어에서 <code>while</code> 을 사용하듯 <code>for</code> 를 사용할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    sum := 1</span>
<span num="7">    for sum &lt; 1000 {</span>
<span num="8">        sum &#43;= sum</span>
<span num="9">    }</span>
<span num="10">    fmt.Println(sum)</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>무한 루프</h2>
  
  
  <p>
    for에서 조건문을 생략하면 무한 루프를 간단하게 표현할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">func main() {</span>
<span num="4">    for {</span>
<span num="5">    }</span>
<span num="6">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>조건문 (If)</h2>
  
  
  <p>
    <code>if</code> 문은 C와 Java와 비슷합니다. 조건 표현을 을 위해 <code>( )</code> 는 사용하지 않습니다. 하지만 실행문을 위한 <code>{ }</code> 는 반드시 작성해야합니다.
  </p>
  

  
  <p>
    (For문과 비슷하죠?)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func sqrt(x float64) string {</span>
<span num="9">    if x &lt; 0 {</span>
<span num="10">        return sqrt(-x) &#43; &#34;i&#34;</span>
<span num="11">    }</span>
<span num="12">    return fmt.Sprint(math.Sqrt(x))</span>
<span num="13">}</span>
<span num="14"></span>
<span num="15">func main() {</span>
<span num="16">    fmt.Println(sqrt(2), sqrt(-4))</span>
<span num="17">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>If와 짧은 명령 사용하기</h2>
  
  
  <p>
    <code>for</code> 처럼 <code>if</code> 에서도 조건문 앞에 짧은 문장을 실행할 수 있습니다.
  </p>
  

  
  <p>
    예제에서는 조건을 비교하기 전에 <code>v := math.Pow(x,n)</code> 을 실행했습니다.
  </p>
  

  
  <p>
    짧은 실행문을 통해 선언된 변수는 <code>if</code> <i>안쪽 범위(scope)</i> 에서 만 사용할 수 있습니다.
  </p>
  

  
  <p>
    (예제 코드의 <code>pow</code> 함수에서 <code>return</code> 전에 <code>v</code> 를 사용해보세요.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func pow(x, n, lim float64) float64 {</span>
<span num="9">    if v := math.Pow(x, n); v &lt; lim {</span>
<span num="10">        return v</span>
<span num="11">    }</span>
<span num="12">    return lim</span>
<span num="13">}</span>
<span num="14"></span>
<span num="15">func main() {</span>
<span num="16">    fmt.Println(</span>
<span num="17">        pow(3, 2, 10),</span>
<span num="18">        pow(3, 3, 20),</span>
<span num="19">    )</span>
<span num="20">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>If와 else</h2>
  
  
  <p>
    <code>if</code> 에서 짧은 명령문을 통해 선언된 변수는 <code>else</code> 블럭 안에서도 사용할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func pow(x, n, lim float64) float64 {</span>
<span num="9">    if v := math.Pow(x, n); v &lt; lim {</span>
<span num="10">        return v</span>
<span num="11">    } else {</span>
<span num="12">        fmt.Printf(&#34;%g &gt;= %g\n&#34;, v, lim)</span>
<span num="13">    }</span>
<span num="14">    // can&#39;t use v here, though</span>
<span num="15">    return lim</span>
<span num="16">}</span>
<span num="17"></span>
<span num="18">func main() {</span>
<span num="19">    fmt.Println(</span>
<span num="20">        pow(3, 2, 10),</span>
<span num="21">        pow(3, 3, 20),</span>
<span num="22">    )</span>
<span num="23">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Exercise: Loops and Functions</h2>
  
  
  <p>
    As a simple way to play with functions and loops, implement the square root function using Newton&#39;s method.
  </p>
  

  
  <p>
    In this case, Newton&#39;s method is to approximate <code>Sqrt(x)</code> by picking a starting point <i>z</i> and then repeating:
  </p>
  

  
  <p>
    To begin with, just repeat that calculation 10 times and see how close you get to the answer for various values (1, 2, 3, ...).
  </p>
  

  
  <p>
    Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small delta). See if that&#39;s more or fewer iterations. How close are you to the <a href="http://golang.org/pkg/math/#Sqrt" target="_blank">math.Sqrt</a>?
  </p>
  

  
  <p>
    Hint: to declare and initialize a floating point value, give it floating point syntax or use a conversion:
  </p>
  

  
  <pre>z := float64(1)
z := 1.0</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">func Sqrt(x float64) float64 {</span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    fmt.Println(Sqrt(2))</span>
<span num="12">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>기본 자료형</h2>
  
  
  <p>
    Go의 기본 자료형은 아래와 같습니다.
  </p>
  

  
  <pre>bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8의 다른 이름(alias)

rune // int32의 다른 이름(alias)
     // 유니코드 코드 포인트 값을 표현합니다. 

float32 float64

complex64 complex128</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math/cmplx&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">var (</span>
<span num="9">    ToBe   bool       = false</span>
<span num="10">    MaxInt uint64     = 1&lt;&lt;64 - 1</span>
<span num="11">    z      complex128 = cmplx.Sqrt(-5 &#43; 12i)</span>
<span num="12">)</span>
<span num="13"></span>
<span num="14">func main() {</span>
<span num="15">    const f = &#34;%T(%v)\n&#34;</span>
<span num="16">    fmt.Printf(f, ToBe, ToBe)</span>
<span num="17">    fmt.Printf(f, MaxInt, MaxInt)</span>
<span num="18">    fmt.Printf(f, z, z)</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>구조체 (Structs)</h2>
  
  
  <p>
    <code>struct</code> 는 필드(데이터)들의 조합입니다.
  </p>
  

  
  <p>
    (그리고 <code>type</code> 선언으로 struct의 이름을 지정할 수 있습니다.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    X int</span>
<span num="7">    Y int</span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    fmt.Println(Vertex{1, 2})</span>
<span num="12">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>구조체 필드</h2>
  
  
  <p>
    구조체에 속한 필드(데이터)는 dot(.) 으로 접근합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    X int</span>
<span num="7">    Y int</span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    v := Vertex{1, 2}</span>
<span num="12">    v.X = 4</span>
<span num="13">    fmt.Println(v.X)</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>포인터 (Pointers)</h2>
  
  
  <p>
    Go에는 포인터가 있지만 포인터 연산은 불가능합니다.
  </p>
  

  
  <p>
    구조체 변수는 구조체 포인터를 이용해서 접근 할 수 있습니다.
  </p>
  

  
  <p>
    포인터를 이용하는 간접적인 접근은 실제 구조체에도 영향을 미칩니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    X int</span>
<span num="7">    Y int</span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    p := Vertex{1, 2}</span>
<span num="12">    q := &amp;p</span>
<span num="13">    q.X = 1e9</span>
<span num="14">    fmt.Println(p)</span>
<span num="15">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>구조체 리터럴 (Struct Literals)</h2>
  
  
  <p>
    구조체 리터럴은 필드와 값을 나열해서 구조체를 새로 할당하는 방법입니다.
  </p>
  

  
  <p>
    원하는 필드를 <code>{Name: value}</code> 구문을 통해 할당할 수 있습니다. (필드의 순서는 상관 없습니다.)
  </p>
  

  
  <p>
    특별한 접두어 <code>&amp;</code> 를 사용하면 구조체 리터럴에 대한 포인터를 생성할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    X, Y int</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">var (</span>
<span num="10">    p = Vertex{1, 2}  // has type Vertex</span>
<span num="11">    q = &amp;Vertex{1, 2} // has type *Vertex</span>
<span num="12">    r = Vertex{X: 1}  // Y:0 is implicit</span>
<span num="13">    s = Vertex{}      // X:0 and Y:0</span>
<span num="14">)</span>
<span num="15"></span>
<span num="16">func main() {</span>
<span num="17">    fmt.Println(p, q, r, s)</span>
<span num="18">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>new 함수</h2>
  
  
  <p>
    <code>new(T)</code> 는 모든 필드가 <i>0(zero value)</i> 이 할당된 <code>T</code> 타입의 포인터를 반환합니다.
  </p>
  

  
  <p>
    ( <i>zero value</i> 는 숫자 타입에서는 <code>0</code> , 참조 타입에서는 <code>nil</code> 을 뜻합니다 )
  </p>
  

  
  <pre>var t *T = new(T)</pre>
  

  
  <p>
    또는
  </p>
  

  
  <pre>t := new(T)</pre>
  

  
  <p>
    위의 변수 t는 <code>T</code> 에서 반환된 포인터를 가집니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    X, Y int</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">func main() {</span>
<span num="10">    v := new(Vertex)</span>
<span num="11">    fmt.Println(v)</span>
<span num="12">    v.X, v.Y = 11, 9</span>
<span num="13">    fmt.Println(v)</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>슬라이스 (Slices)</h2>
  
  
  <p>
    슬라이스는 배열의 값을 가리킵니다(point). 그리고 배열의 길이를 가지고 있습니다.
  </p>
  

  
  <p>
    <code>[]T</code> 는 타입 <code>T</code> 를 가지는 요소의 슬라이스(slice) 입니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    p := []int{2, 3, 5, 7, 11, 13}</span>
<span num="7">    fmt.Println(&#34;p ==&#34;, p)</span>
<span num="8"></span>
<span num="9">    for i := 0; i &lt; len(p); i&#43;&#43; {</span>
<span num="10">        fmt.Printf(&#34;p[%d] == %d\n&#34;,</span>
<span num="11">            i, p[i])</span>
<span num="12">    }</span>
<span num="13">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>슬라이스 자르기 (Slicing slices)</h2>
  
  
  <p>
    슬라이스는 재분할 할 수도 있고, 같은 배열을 가리키는(point) 새로운 슬라이스를 만들 수 도 있습니다.
  </p>
  

  
  <p>
    예제로 살펴보면
  </p>
  

  
  <pre>s[lo:hi]</pre>
  

  
  <p>
    위의 표현은 <code>lo</code> 에서 <code>hi-1</code> 의 요소(element)를 포함하는 슬라이스입니다. 따라서
  </p>
  

  
  <pre>s[lo:lo]</pre>
  

  
  <p>
    는 빈(empty) 슬라이스 이고
  </p>
  

  
  <pre>s[lo:lo&#43;1]</pre>
  

  
  <p>
    는 하나의 요소를 가집니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    p := []int{2, 3, 5, 7, 11, 13}</span>
<span num="7">    fmt.Println(&#34;p ==&#34;, p)</span>
<span num="8">    fmt.Println(&#34;p[1:4] ==&#34;, p[1:4])</span>
<span num="9"></span>
<span num="10">    // missing low index implies 0</span>
<span num="11">    fmt.Println(&#34;p[:3] ==&#34;, p[:3])</span>
<span num="12"></span>
<span num="13">    // missing high index implies len(s)</span>
<span num="14">    fmt.Println(&#34;p[4:] ==&#34;, p[4:])</span>
<span num="15">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>슬라이스 만들기</h2>
  
  
  <p>
    슬라이스는 <code>make</code> 함수로 만들 수 있습니다. 이렇게 생성된 슬라이스는 0을 할당한 배열을 생성하고, 그것을 참조(refer)합니다.
  </p>
  

  
  <pre>a := make([]int, 5)  // len(a)=5</pre>
  

  
  <p>
    <code>make</code> 함수의 세번째 매개변수로 용량(capacity)를 제한할 수 있습니다.
  </p>
  

  
  <pre>b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    a := make([]int, 5)</span>
<span num="7">    printSlice(&#34;a&#34;, a)</span>
<span num="8">    b := make([]int, 0, 5)</span>
<span num="9">    printSlice(&#34;b&#34;, b)</span>
<span num="10">    c := b[:2]</span>
<span num="11">    printSlice(&#34;c&#34;, c)</span>
<span num="12">    d := c[2:5]</span>
<span num="13">    printSlice(&#34;d&#34;, d)</span>
<span num="14">}</span>
<span num="15"></span>
<span num="16">func printSlice(s string, x []int) {</span>
<span num="17">    fmt.Printf(&#34;%s len=%d cap=%d %v\n&#34;,</span>
<span num="18">        s, len(x), cap(x), x)</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>빈 슬라이스</h2>
  
  
  <p>
    슬라이스의 zero value는 <code>nil</code> 입니다.
  </p>
  

  
  <p>
    nil 슬라이스는 길이와 최대 크기가 0입니다.
  </p>
  

  
  <p>
    (슬라이스에 대해 더 알고 싶다면 다음 글을 읽어보세요. <a href="http://golang.org/doc/articles/slices_usage_and_internals.html" target="_blank">Slices: usage and internals</a>)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    var z []int</span>
<span num="7">    fmt.Println(z, len(z), cap(z))</span>
<span num="8">    if z == nil {</span>
<span num="9">        fmt.Println(&#34;nil!&#34;)</span>
<span num="10">    }</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>레인지 (Range, 범위)</h2>
  
  
  <p>
    <code>for</code> 반복문에서 <code>range</code> 를 사용하면 슬라이스나 맵을 순회(iterates)할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}</span>
<span num="6"></span>
<span num="7">func main() {</span>
<span num="8">    for i, v := range pow {</span>
<span num="9">        fmt.Printf(&#34;2**%d = %d\n&#34;, i, v)</span>
<span num="10">    }</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>레인지 (2)</h2>
  
  
  <p>
    <code>_</code> 를 이용해서 인덱스(index)나 값(value)를 무시할 수 있습니다.
  </p>
  

  
  <p>
    만약 인덱스만 필요하다면 “ <code>, value</code> ” 부분을 다 제거하면 됩니다.
  </p>
  

  
  <pre>for i, value := range pow {
    pow[i] = 1 &lt;&lt; uint(i)
}</pre>
  

  
  <p>
    에서
  </p>
  

  
  <pre>for i := range pow {
    pow[i] = 1 &lt;&lt; uint(i)
}</pre>
  

  
  <p>
    처럼 사용할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    pow := make([]int, 10)</span>
<span num="7">    for i := range pow {</span>
<span num="8">        pow[i] = 1 &lt;&lt; uint(i)</span>
<span num="9">    }</span>
<span num="10">    for _, value := range pow {</span>
<span num="11">        fmt.Printf(&#34;%d\n&#34;, value)</span>
<span num="12">    }</span>
<span num="13">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Exercise: Slices</h2>
  
  
  <p>
    Implement <code>Pic</code> . It should return a slice of length <code>dy</code> , each element of which is a slice of <code>dx</code> 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.
  </p>
  

  
  <p>
    The choice of image is up to you. Interesting functions include <code>x^y</code>, <code>(x+y)/2</code>, and <code>x*y</code> .
  </p>
  

  
  <p>
    (You need to use a loop to allocate each <code>[]uint8</code> inside the <code>[][]uint8</code>.)
  </p>
  

  
  <p>
    (Use <code>uint8(intValue)</code> to convert between types.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;code.google.com/p/go-tour/pic&#34;</span>
<span num="4"></span>
<span num="5">func Pic(dx, dy int) [][]uint8 {</span>
<span num="6">}</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    pic.Show(Pic)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>맵 (Maps)</h2>
  
  
  <p>
    맵은 값에 키를 지정합니다.
  </p>
  

  
  <p>
    맵은 반드시 사용하기 전에 <code>make</code> 를 명시해야합니다. (주의: <code>new</code> 가 아닙니다)
  </p>
  

  
  <p>
    <code>make</code> 를 수행하지 않은 <code>nil</code> 에는 값을 할당할 수 없습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    Lat, Long float64</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">var m map[string]Vertex</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    m = make(map[string]Vertex)</span>
<span num="13">    m[&#34;Bell Labs&#34;] = Vertex{</span>
<span num="14">        40.68433, -74.39967,</span>
<span num="15">    }</span>
<span num="16">    fmt.Println(m[&#34;Bell Labs&#34;])</span>
<span num="17">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>맵 리터럴 (Map literals)</h2>
  
  
  <p>
    맵 리터럴은 구조체 리터럴과 비슷하지만 <code>key</code> 를 반드시 지정해야 합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    Lat, Long float64</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">var m = map[string]Vertex{</span>
<span num="10">    &#34;Bell Labs&#34;: Vertex{</span>
<span num="11">        40.68433, -74.39967,</span>
<span num="12">    },</span>
<span num="13">    &#34;Google&#34;: Vertex{</span>
<span num="14">        37.42202, -122.08408,</span>
<span num="15">    },</span>
<span num="16">}</span>
<span num="17"></span>
<span num="18">func main() {</span>
<span num="19">    fmt.Println(m)</span>
<span num="20">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>맵 리터럴 (2)</h2>
  
  
  <p>
    만약 가장 상위의 타입이 타입명이라면 리터럴에서 타입명을 생략해도 됩니다.
  </p>
  

  
  <pre>&#34;Bell Labs&#34;: {40.68433, -74.39967}</pre>
  

  
  <p>
    또는
  </p>
  

  
  <pre>&#34;Bell Labs&#34;: Vertex{40.68433, -74.39967}</pre>
  

  
  <p>
    는 같은 표현입니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">type Vertex struct {</span>
<span num="6">    Lat, Long float64</span>
<span num="7">}</span>
<span num="8"></span>
<span num="9">var m = map[string]Vertex{</span>
<span num="10">    &#34;Bell Labs&#34;: {40.68433, -74.39967},</span>
<span num="11">    &#34;Google&#34;:    {37.42202, -122.08408},</span>
<span num="12">}</span>
<span num="13"></span>
<span num="14">func main() {</span>
<span num="15">    fmt.Println(m)</span>
<span num="16">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>맵 다루기 (Mutating Maps)</h2>
  
  
  <p>
    맵 <code>m</code> 의 요소를 삽입하거나 수정하기:
  </p>
  

  
  <pre>m[key] = elem</pre>
  

  
  <p>
    요소 값 가져오기:
  </p>
  

  
  <pre>elem = m[key]</pre>
  

  
  <p>
    요소 지우기:
  </p>
  

  
  <pre>delete(m, key)</pre>
  

  
  <p>
    키의 존재 여부 확인하기:
  </p>
  

  
  <pre>elem, ok = m[key]</pre>
  

  
  <p>
    위의 <code>ok</code> 의 값은 <code>m</code> 에 <code>key</code> 가 존재한다면 <code>true</code> 존재하지 않으면 <code>false</code> , <code>elem</code> 은 타입에 따라 <i>0(zero value)</i> 가 됩니다.
  </p>
  

  
  <p>
    이처럼 <code>map</code> 을 읽을 때, 존재하지 않는 <code>key</code> 의 반환 값은 타입에 맞는 <i>zero value</i> 입니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    m := make(map[string]int)</span>
<span num="7"></span>
<span num="8">    m[&#34;Answer&#34;] = 42</span>
<span num="9">    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])</span>
<span num="10"></span>
<span num="11">    m[&#34;Answer&#34;] = 48</span>
<span num="12">    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])</span>
<span num="13"></span>
<span num="14">    delete(m, &#34;Answer&#34;)</span>
<span num="15">    fmt.Println(&#34;The value:&#34;, m[&#34;Answer&#34;])</span>
<span num="16"></span>
<span num="17">    v, ok := m[&#34;Answer&#34;]</span>
<span num="18">    fmt.Println(&#34;The value:&#34;, v, &#34;Present?&#34;, ok)</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Exercise: Maps</h2>
  
  
  <p>
    Implement <code>WordCount</code> .  It should return a map of the counts of each “word” in the string <code>s</code> . The <code>wc.Test</code> function runs a test suite against the provided function and prints success or failure.
  </p>
  

  
  <p>
    You might find <a href="http://golang.org/pkg/strings/#Fields" target="_blank">strings.Fields</a> helpful.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;code.google.com/p/go-tour/wc&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">func WordCount(s string) map[string]int {</span>
<span num="8">    return map[string]int{&#34;x&#34;: 1}</span>
<span num="9">}</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    wc.Test(WordCount)</span>
<span num="13">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>함수 값 (Function values)</h2>
  
  
  <p>
    함수도 값 입니다.
  </p>
  

  
  <p>
    (번역자 : 맨 아래 <code>hypot(3,4)</code> 의 hypot 함수를 Println함수의 인자값 처럼 사용 하고 있습니다.)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    hypot := func(x, y float64) float64 {</span>
<span num="10">        return math.Sqrt(x*x &#43; y*y)</span>
<span num="11">    }</span>
<span num="12"></span>
<span num="13">    fmt.Println(hypot(3, 4))</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>함수 클로져 (Function closures)</h2>
  
  
  <p>
    그리고 함수는 클로져(full closures) 입니다.
  </p>
  

  
  <p>
    코드에서 <code>adder</code> 함수는 클로져(closure)를 반환합니다.
  </p>
  

  
  <p>
    각각의 클로져는 자신만의 <code>sum</code> 변수를 가집니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func adder() func(int) int {</span>
<span num="6">    sum := 0</span>
<span num="7">    return func(x int) int {</span>
<span num="8">        sum &#43;= x</span>
<span num="9">        return sum</span>
<span num="10">    }</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    pos, neg := adder(), adder()</span>
<span num="15">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="16">        fmt.Println(</span>
<span num="17">            pos(i),</span>
<span num="18">            neg(-2*i),</span>
<span num="19">        )</span>
<span num="20">    }</span>
<span num="21">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Exercise: Fibonacci closure</h2>
  
  
  <p>
    Let&#39;s have some fun with functions.
  </p>
  

  
  <p>
    Implement a <code>fibonacci</code> function that returns a function (a closure) that returns successive fibonacci numbers.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">// fibonacci is a function that returns</span>
<span num="6">// a function that returns an int.</span>
<span num="7">func fibonacci() func() int {</span>
<span num="8">}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    f := fibonacci()</span>
<span num="12">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="13">        fmt.Println(f())</span>
<span num="14">    }</span>
<span num="15">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>스위치 (Switch)</h2>
  
  
  <p>
    다른 일반적인 언어를 아는 분이라면 <code>switch</code> 에 대해서 잘 알 것입니다.
  </p>
  

  
  <p>
    다른 언어와 다른점은 case의 코드 실행을 마치면 알아서 break를 한다는 점입니다.
  </p>
  

  
  <p>
    ( <code>fallthrough</code> 로 끝나는 case는 스스로 break를 하지 않습니다 )
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;runtime&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Print(&#34;Go runs on &#34;)</span>
<span num="10">    switch os := runtime.GOOS; os {</span>
<span num="11">    case &#34;darwin&#34;:</span>
<span num="12">        fmt.Println(&#34;OS X.&#34;)</span>
<span num="13">    case &#34;linux&#34;:</span>
<span num="14">        fmt.Println(&#34;Linux.&#34;)</span>
<span num="15">    default:</span>
<span num="16">        // freebsd, openbsd,</span>
<span num="17">        // plan9, windows...</span>
<span num="18">        fmt.Printf(&#34;%s.&#34;, os)</span>
<span num="19">    }</span>
<span num="20">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>스위치 동작 순서</h2>
  
  
  <p>
    스위치의 각 조건은 위에서 아래로 평가합니다. 만약 조건이 참인 case를 찾으면 평가를 마칩니다.
  </p>
  

  
  <p>
    (예를 들어
  </p>
  

  
  <pre>switch i {
case 0:
case f():
}</pre>
  

  
  <p>
    에서 <code>i==0</code> 이라면 <code>f()</code> 는 실행하지 않습니다)
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;time&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(&#34;When&#39;s Saturday?&#34;)</span>
<span num="10">    today := time.Now().Weekday()</span>
<span num="11">    switch time.Saturday {</span>
<span num="12">    case today &#43; 0:</span>
<span num="13">        fmt.Println(&#34;Today.&#34;)</span>
<span num="14">    case today &#43; 1:</span>
<span num="15">        fmt.Println(&#34;Tomorrow.&#34;)</span>
<span num="16">    case today &#43; 2:</span>
<span num="17">        fmt.Println(&#34;In two days.&#34;)</span>
<span num="18">    default:</span>
<span num="19">        fmt.Println(&#34;Too far away.&#34;)</span>
<span num="20">    }</span>
<span num="21">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>조건을 생략한 스위치</h2>
  
  
  <p>
    스위치에서 조건을 생략하면 &#34; <code>switch</code> <code>true</code> &#34; 와 같습니다.
  </p>
  

  
  <p>
    만약 긴 if-then-else 를 작성해야 할 때, 이 구조를 사용하면 코드를 깔끔하게 작성할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;time&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    t := time.Now()</span>
<span num="10">    switch {</span>
<span num="11">    case t.Hour() &lt; 12:</span>
<span num="12">        fmt.Println(&#34;Good morning!&#34;)</span>
<span num="13">    case t.Hour() &lt; 17:</span>
<span num="14">        fmt.Println(&#34;Good afternoon.&#34;)</span>
<span num="15">    default:</span>
<span num="16">        fmt.Println(&#34;Good evening.&#34;)</span>
<span num="17">    }</span>
<span num="18">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Advanced Exercise: Complex cube roots</h2>
  
  
  <p>
    Let&#39;s explore Go&#39;s built-in support for complex numbers via the <code>complex64</code> and <code>complex128</code> types. For cube roots, Newton&#39;s method amounts to repeating:
  </p>
  

  
  <p>
    Find the cube root of 2, just to make sure the algorithm works. There is a <a href="http://golang.org/pkg/math/cmplx/#Pow" target="_blank">Pow</a> function in the <code>math/cmplx</code> package.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func Cbrt(x complex128) complex128 {</span>
<span num="6">}</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    fmt.Println(Cbrt(2))</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide nocode">
	
  <h2>메소드와 인터페이스</h2>
  

</div>

<div class="slide">
	
  <h2>메소드 (Methods)</h2>
  
  
  <p>
    고에는 클래스가 없습니다. 하지만 메소드를 구조체(struct)에 붙일 수 있습니다.
  </p>
  

  
  <p>
    <i>메소드 리시버(method receiver)</i> 는 <code>func</code> 키워드와 메소드의 이름 사이에 인자로 들어갑니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Vertex struct {</span>
<span num="9">    X, Y float64</span>
<span num="10">}</span>
<span num="11"></span>
<span num="12">func (v *Vertex) Abs() float64 {</span>
<span num="13">    return math.Sqrt(v.X*v.X &#43; v.Y*v.Y)</span>
<span num="14">}</span>
<span num="15"></span>
<span num="16">func main() {</span>
<span num="17">    v := &amp;Vertex{3, 4}</span>
<span num="18">    fmt.Println(v.Abs())</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>메소드 (2)</h2>
  
  
  <p>
    사실 메소드는 구조체(struct) 뿐 아니라 아무 타입(type)에나 붙일 수 있습니다.
  </p>
  

  
  <p>
    다른 패키지에 있는 타입이나 기본 타입들에 메소드를 붙이는 것은 불가능합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type MyFloat float64</span>
<span num="9"></span>
<span num="10">func (f MyFloat) Abs() float64 {</span>
<span num="11">    if f &lt; 0 {</span>
<span num="12">        return float64(-f)</span>
<span num="13">    }</span>
<span num="14">    return float64(f)</span>
<span num="15">}</span>
<span num="16"></span>
<span num="17">func main() {</span>
<span num="18">    f := MyFloat(-math.Sqrt2)</span>
<span num="19">    fmt.Println(f.Abs())</span>
<span num="20">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>포인터 리시버를 가지는 메소드</h2>
  
  
  <p>
    메소드는 이름이 있는 타입 또는 이름이 있는 타입의 포인터와 연결할 수 있습니다.
  </p>
  

  
  <p>
    방금 두 개의 <code>Abs</code> 메소드를 보았는데, 하나는 <code>*Vertex</code> 라는 포인터 타입의 메소드고, 다른 하나는 <code>MyFloat</code> 값 타입의 메소드 입니다.
  </p>
  

  
  <p>
    포인터 리시버를 사용하는 이유는 두 가지 입니다. 첫째, 메소드가 호출될 때 마다 값이 복사되는 것(큰 구조체 타입인 경우 값이 복사되는 것은 비효율적이죠)을 방지하기 위함 입니다. 다른 이유는 메소드에서 리시버 포인터가 가리키는 값을 수정하기 위함 입니다.
  </p>
  

  
  <p>
    <code>*Vertex</code> 타입의 리시버 대신 <code>Vertex</code> 를 사용하도록 메소드 <code>Abs</code> 와 <code>Scale</code> 의 선언부분을 바꿔 보세요.
  </p>
  

  
  <p>
    <code>v</code> 를 <code>Vertex</code> 타입으로 받으면 <code>Scale</code> 메소드가 더 이상 동작하지 않습니다. <code>Scale</code> 은 <code>v</code> 를 바꾸는데, <code>v</code> 가 (포인터가 아닌) 값 타입이기 때문에 <code>Vertex</code> 타입인 복사본에 작업을 하기 때문에 원래의 값은 바뀌지 않습니다.
  </p>
  

  
  <p>
    <code>Abs</code> 의 경우는 다릅니다. 여기서는 <code>v</code> 를 읽기만 하기 때문에, (포인터가 가리키는) 원래의 값이건 복사본이건 상관이 없게 됩니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Vertex struct {</span>
<span num="9">    X, Y float64</span>
<span num="10">}</span>
<span num="11"></span>
<span num="12">func (v *Vertex) Scale(f float64) {</span>
<span num="13">    v.X = v.X * f</span>
<span num="14">    v.Y = v.Y * f</span>
<span num="15">}</span>
<span num="16"></span>
<span num="17">func (v *Vertex) Abs() float64 {</span>
<span num="18">    return math.Sqrt(v.X*v.X &#43; v.Y*v.Y)</span>
<span num="19">}</span>
<span num="20"></span>
<span num="21">func main() {</span>
<span num="22">    v := &amp;Vertex{3, 4}</span>
<span num="23">    v.Scale(5)</span>
<span num="24">    fmt.Println(v, v.Abs())</span>
<span num="25">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>인터페이스 (Interface)</h2>
  
  
  <p>
    인터페이스는 메소드의 집합으로 정의됩니다.
  </p>
  

  
  <p>
    그 메소드들의 구현되어 있는 타입의 값은 모두 인터페이스 타입의 값이 될 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;math&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Abser interface {</span>
<span num="9">    Abs() float64</span>
<span num="10">}</span>
<span num="11"></span>
<span num="12">func main() {</span>
<span num="13">    var a Abser</span>
<span num="14">    f := MyFloat(-math.Sqrt2)</span>
<span num="15">    v := Vertex{3, 4}</span>
<span num="16"></span>
<span num="17">    a = f  // a MyFloat implements Abser</span>
<span num="18">    a = &amp;v // a *Vertex implements Abser</span>
<span num="19">    a = v  // a Vertex, does NOT</span>
<span num="20">    // implement Abser</span>
<span num="21"></span>
<span num="22">    fmt.Println(a.Abs())</span>
<span num="23">}</span>
<span num="24"></span>
<span num="25">type MyFloat float64</span>
<span num="26"></span>
<span num="27">func (f MyFloat) Abs() float64 {</span>
<span num="28">    if f &lt; 0 {</span>
<span num="29">        return float64(-f)</span>
<span num="30">    }</span>
<span num="31">    return float64(f)</span>
<span num="32">}</span>
<span num="33"></span>
<span num="34">type Vertex struct {</span>
<span num="35">    X, Y float64</span>
<span num="36">}</span>
<span num="37"></span>
<span num="38">func (v *Vertex) Abs() float64 {</span>
<span num="39">    return math.Sqrt(v.X*v.X &#43; v.Y*v.Y)</span>
<span num="40">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>인터페이스 암시적으로 충족됩니다</h2>
  
  
  <p>
    타입이 인터페이스의 메소드들을 구현하면 인터페이스를 구현한 게 됩니다.
  </p>
  

  
  <p>
    <i>이를 위해 명시적으로 선언할 게 없습니다.</i>
  </p>
  

  
  <p>
    암시적 인터페이스는 인터페이스를 정의한 패키지로 부터 구현 패키지를 분리(decouple)해 줍니다. 다른 의존성 또한 없음은 물론입니다.
  </p>
  

  
  <p>
    이 특징은 상세하게 인터페이스를 정의하게 독려합니다. 모든 구현을 찾아 새 인터페이스 이름으로 태그할 필요가 없기 때문입니다.
  </p>
  

  
  <p>
    <a href="http://golang.org/pkg/io/" target="_blank">패키지 io</a>에 <code>Reader</code> 와 <code>Writer</code> 가 정의되어 있습니다. 따로 정의할 필요가 없습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;os&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Reader interface {</span>
<span num="9">    Read(b []byte) (n int, err error)</span>
<span num="10">}</span>
<span num="11"></span>
<span num="12">type Writer interface {</span>
<span num="13">    Write(b []byte) (n int, err error)</span>
<span num="14">}</span>
<span num="15"></span>
<span num="16">type ReadWriter interface {</span>
<span num="17">    Reader</span>
<span num="18">    Writer</span>
<span num="19">}</span>
<span num="20"></span>
<span num="21">func main() {</span>
<span num="22">    var w Writer</span>
<span num="23"></span>
<span num="24">    // os.Stdout implements Writer</span>
<span num="25">    w = os.Stdout</span>
<span num="26"></span>
<span num="27">    fmt.Fprintf(w, &#34;hello, writer\n&#34;)</span>
<span num="28">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>에러(error)</h2>
  
  
  <p>
    에러 문장(string)으로 자신을 표현할 수 있는 것은 모두 에러입니다. 이 아이디어는 문자열(string)을 반환하는 하나의 메소드 <code>Error</code> 로 구성된 내장 인터페이스 타입 <code>error</code> 에서 나왔습니다.
  </p>
  

  
  <pre>type error interface {
    Error() string
}</pre>
  

  
  <p>
    <code>fmt</code> 패키지의 다양한 출력 루틴들은 <code>error</code> 의 출력을 요청받았을 때 자동으로 이 메소드를 호출합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;time&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type MyError struct {</span>
<span num="9">    When time.Time</span>
<span num="10">    What string</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13">func (e *MyError) Error() string {</span>
<span num="14">    return fmt.Sprintf(&#34;at %v, %s&#34;,</span>
<span num="15">        e.When, e.What)</span>
<span num="16">}</span>
<span num="17"></span>
<span num="18">func run() error {</span>
<span num="19">    return &amp;MyError{</span>
<span num="20">        time.Now(),</span>
<span num="21">        &#34;it didn&#39;t work&#34;,</span>
<span num="22">    }</span>
<span num="23">}</span>
<span num="24"></span>
<span num="25">func main() {</span>
<span num="26">    if err := run(); err != nil {</span>
<span num="27">        fmt.Println(err)</span>
<span num="28">    }</span>
<span num="29">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>연습: 에러</h2>
  
  
  <p>
    당신의 <code>Sqrt</code> 함수를 이전 연습에서 복사하고 <code>error</code> 값을 반환하도록 수정하십시오.
  </p>
  

  
  <p>
    <code>Sqrt</code> 함수는 복소수를 지원하지 않기 때문에, 음수가 주어지면 <code>nil</code> 이 아닌 에러 값을 반환해야 합니다.
  </p>
  

  
  <p>
    새로운 타입을 만드십시오.
  </p>
  

  
  <pre>type ErrNegativeSqrt float64</pre>
  

  
  <p>
    and make it an <code>error</code> by giving it a


    그리고 아래 메소드를 구현함으로써 그 타입이 <code>error</code> 가 되게 하십시오.
  </p>
  

  
  <pre>func (e ErrNegativeSqrt) Error() string</pre>
  

  
  <p>
    이는 <code>ErrNegativeSqrt(-2).Error()</code> 가 <code>&#34;cannot Sqrt negative number: -2&#34;</code> 를 반환하는 그러한 메소드입니다.
  </p>
  

  
  <p>
    <b>Note:</b> <code>Error</code> 메소드 내에서 <code>fmt.Print(e)</code> 를 호출하면 이 프로그램을 무한루프에 빠질 것입니다. <code>e</code> 를 바꿈으로써 이 문제를 피할 수 있습니다. 왜 그럴까요?
  </p>
  

  
  <p>
    음수가 주어졌을 때 <code>ErrNegativeSqrt</code> 값을 반환하도록 당신의 <code>Sqrt</code> 함수를 바꾸십시오.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">func Sqrt(f float64) (float64, error) {</span>
<span num="8">    return 0, nil</span>
<span num="9">}</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    fmt.Println(Sqrt(2))</span>
<span num="13">    fmt.Println(Sqrt(-2))</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>웹 서버</h2>
  
  
  <p>
    <a href="http://golang.org/pkg/net/http/" target="_blank">Package http</a> 는 <code>http.Handler</code> 를 구현한 어떠 값을 사용하여 HTTP 요청(requests)을 제공합니다.
  </p>
  

  
  <pre>package http

type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}</pre>
  

  
  <p>
    이 예제에서, <code>Hello</code> 라는 타입은 <code>http.Handler</code> 를 구현합니다.
  </p>
  

  
  <p>
    이 코드를 로컬에서 실행하고, <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> 에 접속해보세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;net/http&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Hello struct{}</span>
<span num="9"></span>
<span num="10">func (h Hello) ServeHTTP(</span>
<span num="11">    w http.ResponseWriter,</span>
<span num="12">    r *http.Request) {</span>
<span num="13">    fmt.Fprint(w, &#34;Hello!&#34;)</span>
<span num="14">}</span>
<span num="15"></span>
<span num="16">func main() {</span>
<span num="17">    var h Hello</span>
<span num="18">    http.ListenAndServe(&#34;localhost:4000&#34;, h)</span>
<span num="19">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>연습: HTTP 핸들러</h2>
  
  
  <p>
    아래 나오는 타입을 구현하고 그 타입의 ServeHTTP 메소드를 정의하십시오. 그 메소드를 당신의 웹 서버에서 특정 경로를 처리할 수 있도록 등록하십시오.
  </p>
  

  
  <pre>type String string

type Struct struct {
    Greeting string
    Punct    string
    Who      string
}</pre>
  

  
  <p>
    예컨대, 당신은 아래와 같이 핸들러를 등록할 수 있어야 합니다.
  </p>
  

  
  <pre>http.Handle(&#34;/string&#34;, String(&#34;I&#39;m a frayed knot.&#34;))
http.Handle(&#34;/struct&#34;, &amp;Struct{&#34;Hello&#34;, &#34;:&#34;, &#34;Gophers!&#34;})</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;net/http&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">func main() {</span>
<span num="8">    // your http.Handle calls here</span>
<span num="9">    http.ListenAndServe(&#34;localhost:4000&#34;, nil)</span>
<span num="10">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>이미지</h2>
  
  
  <p>
    <a href="http://golang.org/pkg/image/#Image" target="_blank">Package image</a> 는 <code>Image</code> 인터페이스를 정의합니다.
  </p>
  

  
  <pre>package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}</pre>
  

  
  <p>
    (모든 세부사항에 대한 것은 <a href="http://golang.org/pkg/image/#Image" target="_blank">이 문서</a> 를 참고하십시오.)
  </p>
  

  
  <p>
    또한, <code>color.Color</code> 와 <code>color.Model</code> 는 인터페이스이지만, 미리 정의된 구현체인 <code>color.RGBA</code> 와 <code>color.RGBAModel</code> 을 사용함으로써 그 인터페이스를 무시할 수 있습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;image&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    m := image.NewRGBA(image.Rect(0, 0, 100, 100))</span>
<span num="10">    fmt.Println(m.Bounds())</span>
<span num="11">    fmt.Println(m.At(0, 0).RGBA())</span>
<span num="12">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>연습: 이미지</h2>
  
  
  <p>
    이전의 연습에서 당신이 작성한 그림 생성기를 기억하십니까? 다른 생성기를 만들어봅시다. 하지만 이번에는 데이터의 슬라이스 대신에 <code>image.Image</code> 의 구현체를 반환할 것입니다.
  </p>
  

  
  <p>
    당신 자신의 <code>Image</code> 타입을 정의하시고, <a href="http://golang.org/pkg/image/#Image" target="_blank">필수 함수들</a> 을 구현하신 다음, <code>pic.ShowImage</code> 를 호출하십시오.
  </p>
  

  
  <p>
    <code>Bounds</code> 는 <code>image.Rect(0, 0, w, h)</code> 와 같은 <code>image.Rectangle</code> 을 반환해야 합니다.
  </p>
  

  
  <p>
    <code>ColorModel</code> 은 <code>color.RGBAModel</code> 을 반환해야 합니다.
  </p>
  

  
  <p>
    <code>At</code> 은 하나의 컬러를 반환해야 합니다; 지난 그림 생성기에서 값 <code>v</code> 는 <code>color.RGBA{v, v, 255, 255}</code> 와 같습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;code.google.com/p/go-tour/pic&#34;</span>
<span num="5">    &#34;image&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">type Image struct{}</span>
<span num="9"></span>
<span num="10">func main() {</span>
<span num="11">    m := Image{}</span>
<span num="12">    pic.ShowImage(m)</span>
<span num="13">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>연습: Rot13 Reader</h2>
  
  
  <p>
    어떤 식으로든 스트림을 수정하여 다른 <code>io.Reader</code> 를 감싸는 <a href="http://golang.org/pkg/io/#Reader" target="_blank">io.Reader</a> 는 흔한 패턴입니다.
  </p>
  

  
  <p>
    예컨대, <a href="http://golang.org/pkg/compress/gzip/#NewReader" target="_blank">gzip.NewReader</a> 함수는 <code>io.Reader</code> (gzip으로 압축된 데이터의 스트림) 를 가지고, <code>io.Reader</code> (압축 해제된 데이터의 스트림) 를 구현한 <code>*gzip.Reader</code> 를 반환합니다.
  </p>
  

  
  <p>
    <a href="http://en.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a> 치환 암호화를 모든 알파벳 문자에 적용함으로써 스트림을 수정하며 <code>io.Reader</code> 를 구현하고 <code>io.Reader</code> 로 부터 읽는 <code>rot13Reader</code> 를 구현하십시오.
  </p>
  

  
  <p>
    <code>rot13Reader</code> 타입은 당신을 위해 제공됩니다. 이 타입의 <code>Read</code> 함수를 구현함으로써 <code>io.Reader</code> 을 만들어 보십시오.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;io&#34;</span>
<span num="5">    &#34;os&#34;</span>
<span num="6">    &#34;strings&#34;</span>
<span num="7">)</span>
<span num="8"></span>
<span num="9">type rot13Reader struct {</span>
<span num="10">    r io.Reader</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    s := strings.NewReader(</span>
<span num="15">        &#34;Lbh penpxrq gur pbqr!&#34;)</span>
<span num="16">    r := rot13Reader{s}</span>
<span num="17">    io.Copy(os.Stdout, &amp;r)</span>
<span num="18">}</span>
</pre>


</div>


</div>

<div class="slide nocode">
	
  <h2>동시성</h2>
  

</div>

<div class="slide">
	
  <h2>고루틴(Goroutines)</h2>
  
  
  <p>
    <i>고루틴</i> 은 Go 런타임에 의해 관리되는 경량 쓰레드입니다.
  </p>
  

  
  <pre>go f(x, y, z)</pre>
  

  
  <p>
    위의 코드는 새로운 고루틴을 시작시킵니다.
  </p>
  

  
  <pre>f(x, y, z)</pre>
  

  
  <p>
    현재의 고루틴에서 <code>f</code> , <code>x</code> , <code>y</code> , <code>z</code> 가 평가(evaluation)되고, 새로운 고루틴에서 <code>f</code> 가 수행(execution)됩니다.
  </p>
  

  
  <p>
    고루틴은 동일한 주소 공간에서 실행되므로, 공유되는 자원으로의 접근은 반드시 동기화 되어야 합니다. `<a href="http://golang.org/pkg/sync/" target="_blank">sync</a>` 패키지가 이를 위해 유용한 기본 기능을 제공합니다. Go 에서는 그외에도 다양한 기본 기능을 제공하니 크게 필요치 않을 테지만요. (다음 슬라이드를 보세요.) 
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;time&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func say(s string) {</span>
<span num="9">    for i := 0; i &lt; 5; i&#43;&#43; {</span>
<span num="10">        time.Sleep(100 * time.Millisecond)</span>
<span num="11">        fmt.Println(s)</span>
<span num="12">    }</span>
<span num="13">}</span>
<span num="14"></span>
<span num="15">func main() {</span>
<span num="16">    go say(&#34;world&#34;)</span>
<span num="17">    say(&#34;hello&#34;)</span>
<span num="18">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>채널(Channels)</h2>
  
  
  <p>
    채널은 채널 연산자 <code>&lt;-</code> 를 이용해 값을 주고 받을 수 있는, 타입이 존재하는 파이프입니다.
  </p>
  

  
  <pre>ch &lt;- v    // v 를 ch로 보냅니다.
v := &lt;-ch  // ch로부터 값을 받아서
           // v 로 넘깁니다.</pre>
  

  
  <p>
    (데이터가 화살표 방향에 따라 흐릅니다.)
  </p>
  

  
  <p>
    맵이나 슬라이스처럼, 채널은 사용되기 전에 생성되어야 합니다:
  </p>
  

  
  <pre>ch := make(chan int)</pre>
  

  
  <p>
    기본적으로, 송/수신은 상대편이 준비될 때까지 블록됩니다. 이런 특성이 고루틴이 명시적인 락이나 조건 없이도 동기화 될 수 있도록 돕습니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func sum(a []int, c chan int) {</span>
<span num="6">    sum := 0</span>
<span num="7">    for _, v := range a {</span>
<span num="8">        sum &#43;= v</span>
<span num="9">    }</span>
<span num="10">    c &lt;- sum // send sum to c</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">    a := []int{7, 2, 8, -9, 4, 0}</span>
<span num="15"></span>
<span num="16">    c := make(chan int)</span>
<span num="17">    go sum(a[:len(a)/2], c)</span>
<span num="18">    go sum(a[len(a)/2:], c)</span>
<span num="19">    x, y := &lt;-c, &lt;-c // receive from c</span>
<span num="20"></span>
<span num="21">    fmt.Println(x, y, x&#43;y)</span>
<span num="22">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>버퍼링되는 채널</h2>
  
  
  <p>
    채널은 <i>버퍼링</i> 될 수 있습니다. <code>make</code> 에 두번째 인자로 버퍼 용량을 넣음으로써 해당 용량만큼 버퍼링되는 채널을 생성할 수 있습니다:
  </p>
  

  
  <pre>ch := make(chan int, 100)</pre>
  

  
  <p>
    버퍼링되는 채널로의 송신은 버퍼가 꽉 찰 때까지 블록됩니다. 수신측은 버퍼가 빌 때 블록됩니다.
  </p>
  

  
  <p>
    예제를 수정해서 버퍼를 넘치게 해보고 어떻게 동작하는지 확인해 보세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func main() {</span>
<span num="6">    c := make(chan int, 2)</span>
<span num="7">    c &lt;- 1</span>
<span num="8">    c &lt;- 2</span>
<span num="9">    fmt.Println(&lt;-c)</span>
<span num="10">    fmt.Println(&lt;-c)</span>
<span num="11">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>Range와 Close</h2>
  
  
  <p>
    데이터 송신측은 더이상 보낼 값이 없다는 것을 알리기 위해 채널을 <code>close</code> 할 수 있습니다. 수신측은 다음과 같이 수신 코드에 두번째 인자를 줌으로써 채널이 닫혔는지 테스트 할 수 있습니다.
  </p>
  

  
  <pre>v, ok := &lt;-ch</pre>
  

  
  <p>
    채널이 이미 닫혔고 더이상 받을 값이 없다면 <code>ok</code> 는 <code>false</code> 가 됩니다.
  </p>
  

  
  <p>
    <code>for i := range c</code> 반복문은 채널이 닫힐 때까지 계속해서 값을 받습니다.
  </p>
  

  
  <p>
    <b>주의:</b> 송신측만 채널을 닫을 수 있습니다. 수신측에선 불가능합니다. 이미 닫힌 채널에 데이터를 보내면 패닉이 일어납니다.
  </p>
  

  
  <p>
    <b>또하나의 주의</b>: 채널은 파일과 다릅니다; 항상 닫을 필요는 없습니다. 채널을 닫는 행위는 오로지 수신측에게 더이상 보낼 값이 없다고 말해야 할때만 행해지면 됩니다. <code>range</code> 루프를 종료시켜야 할 때처럼요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">func fibonacci(n int, c chan int) {</span>
<span num="8">    x, y := 0, 1</span>
<span num="9">    for i := 0; i &lt; n; i&#43;&#43; {</span>
<span num="10">        c &lt;- x</span>
<span num="11">        x, y = y, x&#43;y</span>
<span num="12">    }</span>
<span num="13">    close(c)</span>
<span num="14">}</span>
<span num="15"></span>
<span num="16">func main() {</span>
<span num="17">    c := make(chan int, 10)</span>
<span num="18">    go fibonacci(cap(c), c)</span>
<span num="19">    for i := range c {</span>
<span num="20">        fmt.Println(i)</span>
<span num="21">    }</span>
<span num="22">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>셀렉트(Select)</h2>
  
  
  <p>
    <code>select</code> 구문은 고루틴이 다수의 통신 동작으로부터 수행 준비를 기다릴 수 있게 합니다.
  </p>
  

  
  <p>
    <code>select</code> 는 <code>case</code> 구문으로 받는 통신 동작들 중 하나가 수행될 수 있을 때까지 수행을 블록합니다. 다수의 채널이 동시에 준비되면 그 중 하나를 무작위로 선택합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;fmt&#34;</span>
<span num="4"></span>
<span num="5">func fibonacci(c, quit chan int) {</span>
<span num="6">    x, y := 0, 1</span>
<span num="7">    for {</span>
<span num="8">        select {</span>
<span num="9">        case c &lt;- x:</span>
<span num="10">            x, y = y, x&#43;y</span>
<span num="11">        case &lt;-quit:</span>
<span num="12">            fmt.Println(&#34;quit&#34;)</span>
<span num="13">            return</span>
<span num="14">        }</span>
<span num="15">    }</span>
<span num="16">}</span>
<span num="17"></span>
<span num="18">func main() {</span>
<span num="19">    c := make(chan int)</span>
<span num="20">    quit := make(chan int)</span>
<span num="21">    go func() {</span>
<span num="22">        for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="23">            fmt.Println(&lt;-c)</span>
<span num="24">        }</span>
<span num="25">        quit &lt;- 0</span>
<span num="26">    }()</span>
<span num="27">    fibonacci(c, quit)</span>
<span num="28">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>셀렉트의 디폴트(default) 케이스</h2>
  
  
  <p>
    <code>select</code> 의 <code>default</code> 케이스는 현재 수행 준비가 완료된 케이스가 없을 때 수행됩니다.
  </p>
  

  
  <p>
    블로킹 없이(비동기적인) 송/수신을 하고자 할 때 <code>default</code> 케이스를 사용하세요.
  </p>
  

  
  <pre>select {
case i := &lt;-c:
    // i를 사용
default:
    // c로부터의 수신은 블록된 상태
}</pre>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">    &#34;time&#34;</span>
<span num="6">)</span>
<span num="7"></span>
<span num="8">func main() {</span>
<span num="9">    tick := time.Tick(1e8)</span>
<span num="10">    boom := time.After(5e8)</span>
<span num="11">    for {</span>
<span num="12">        select {</span>
<span num="13">        case &lt;-tick:</span>
<span num="14">            fmt.Println(&#34;tick.&#34;)</span>
<span num="15">        case &lt;-boom:</span>
<span num="16">            fmt.Println(&#34;BOOM!&#34;)</span>
<span num="17">            return</span>
<span num="18">        default:</span>
<span num="19">            fmt.Println(&#34;    .&#34;)</span>
<span num="20">            time.Sleep(5e7)</span>
<span num="21">        }</span>
<span num="22">    }</span>
<span num="23">}</span>
</pre>


</div>


</div>

<div class="slide nocode">
	
  <h2>연습: 동등한 이진 트리</h2>
  
  
  <p>
    노드(leaf)들에 있는 값들의 정렬 순열는 같지만 생김새가 다른 이진트리가 있을 수 있습니다. 예를들어, 다음 그림의 두 이진 트리를 정렬 순열는 1, 1, 2, 3, 5, 8, 13 으로 같습니다.
  </p>
  

  
  <p>
    대부분의 프로그래밍 언어에서 두 이진 트리가 같은 순열인지를 검사하는 함수의 구현은 복잡합니다. 이제 고의 동시성과 채널을 사용한 단순한 방법으로 해결해 봅시다.
  </p>
  

  
  <p>
    이 예제는 다음의 <code>Tree</code> 구조체가 정의된 <code>tree</code> 패키지를 사용합니다.
  </p>
  

  
  <pre>type Tree struct {
    Left  *Tree
    Value int
    Right *Tree
}</pre>
  


</div>

<div class="slide">
	
  <h2>연습: 동등한 이진 트리</h2>
  
  
  <p>
    <b>1.</b> <code>Walk</code> 함수를 구현하세요.
  </p>
  

  
  <p>
    <b>2.</b> <code>Walk</code> 함수를 테스트 해 보세요.
  </p>
  

  
  <p>
    함수 <code>tree.New(k)</code> 는 <code>k</code> , <code>2k</code> , <code>3k</code> , ..., <code>10k</code> 의 값을 가지는, 무작위로 구성된 이진트리를 만들어 냅니다.
  </p>
  

  
  <p>
    채널 <code>ch</code> 를 만들고, 작성한 <code>Walk</code> 함수의 인자로 넣어 줍니다.
  </p>
  

  
  <pre>go Walk(tree.New(1), ch)</pre>
  

  
  <p>
    이제 채널에서 10개의 값을 읽어 봅니다. 읽힌 값은 1, 2, 3, ..., 10 이어야 합니다.
  </p>
  

  
  <p>
    <b>3.</b> <code>Walk</code> 함수를 사용해 두 트리 <code>t1</code> 과 <code>t2</code> 이 값은 값들을 가지고 있는지 비교하는 <code>Same</code> 함수를 구현해 보세요.
  </p>
  

  
  <p>
    <b>4.</b> <code>Same</code> 함수를 테스트 해 보세요.
  </p>
  

  
  <p>
    <code>Same(tree.New(1), tree.New(1))</code> 의 수행결과는 true, <code>Same(tree.New(1), tree.New(2))</code> 의 수행 결과는 false 이어야 합니다.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import &#34;code.google.com/p/go-tour/tree&#34;</span>
<span num="4"></span>
<span num="5">// Walk walks the tree t sending all values</span>
<span num="6">// from the tree to the channel ch.</span>
<span num="7">func Walk(t *tree.Tree, ch chan int)</span>
<span num="8"></span>
<span num="9">// Same determines whether the trees</span>
<span num="10">// t1 and t2 contain the same values.</span>
<span num="11">func Same(t1, t2 *tree.Tree) bool</span>
<span num="12"></span>
<span num="13">func main() {</span>
<span num="14">}</span>
</pre>


</div>


</div>

<div class="slide">
	
  <h2>연습: 웹 크롤러</h2>
  
  
  <p>
    이 연습에서는 고의 동시성 기능을 사용해 웹 크롤러를 병렬화 해 볼 것입니다.
  </p>
  

  
  <p>
    <code>Crawl</code> 함수를 고쳐서, 같은 URL을 두번 가져오는 중복을 피하면서 URL들을 병렬로 패치하게 고쳐보세요.
  </p>
  

  <div class="source">


<pre><span num="1">package main</span>
<span num="2"></span>
<span num="3">import (</span>
<span num="4">    &#34;fmt&#34;</span>
<span num="5">)</span>
<span num="6"></span>
<span num="7">type Fetcher interface {</span>
<span num="8">    // Fetch returns the body of URL and</span>
<span num="9">    // a slice of URLs found on that page.</span>
<span num="10">    Fetch(url string) (body string, urls []string, err error)</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13">// Crawl uses fetcher to recursively crawl</span>
<span num="14">// pages starting with url, to a maximum of depth.</span>
<span num="15">func Crawl(url string, depth int, fetcher Fetcher) {</span>
<span num="16">    // TODO: Fetch URLs in parallel.</span>
<span num="17">    // TODO: Don&#39;t fetch the same URL twice.</span>
<span num="18">    // This implementation doesn&#39;t do either:</span>
<span num="19">    if depth &lt;= 0 {</span>
<span num="20">        return</span>
<span num="21">    }</span>
<span num="22">    body, urls, err := fetcher.Fetch(url)</span>
<span num="23">    if err != nil {</span>
<span num="24">        fmt.Println(err)</span>
<span num="25">        return</span>
<span num="26">    }</span>
<span num="27">    fmt.Printf(&#34;found: %s %q\n&#34;, url, body)</span>
<span num="28">    for _, u := range urls {</span>
<span num="29">        Crawl(u, depth-1, fetcher)</span>
<span num="30">    }</span>
<span num="31">    return</span>
<span num="32">}</span>
<span num="33"></span>
<span num="34">func main() {</span>
<span num="35">    Crawl(&#34;http://golang.org/&#34;, 4, fetcher)</span>
<span num="36">}</span>
<span num="37"></span>
<span num="38">// fakeFetcher is Fetcher that returns canned results.</span>
<span num="39">type fakeFetcher map[string]*fakeResult</span>
<span num="40"></span>
<span num="41">type fakeResult struct {</span>
<span num="42">    body string</span>
<span num="43">    urls []string</span>
<span num="44">}</span>
<span num="45"></span>
<span num="46">func (f *fakeFetcher) Fetch(url string) (string, []string, error) {</span>
<span num="47">    if res, ok := (*f)[url]; ok {</span>
<span num="48">        return res.body, res.urls, nil</span>
<span num="49">    }</span>
<span num="50">    return &#34;&#34;, nil, fmt.Errorf(&#34;not found: %s&#34;, url)</span>
<span num="51">}</span>
<span num="52"></span>
<span num="53">// fetcher is a populated fakeFetcher.</span>
<span num="54">var fetcher = &amp;fakeFetcher{</span>
<span num="55">    &#34;http://golang.org/&#34;: &amp;fakeResult{</span>
<span num="56">        &#34;The Go Programming Language&#34;,</span>
<span num="57">        []string{</span>
<span num="58">            &#34;http://golang.org/pkg/&#34;,</span>
<span num="59">            &#34;http://golang.org/cmd/&#34;,</span>
<span num="60">        },</span>
<span num="61">    },</span>
<span num="62">    &#34;http://golang.org/pkg/&#34;: &amp;fakeResult{</span>
<span num="63">        &#34;Packages&#34;,</span>
<span num="64">        []string{</span>
<span num="65">            &#34;http://golang.org/&#34;,</span>
<span num="66">            &#34;http://golang.org/cmd/&#34;,</span>
<span num="67">            &#34;http://golang.org/pkg/fmt/&#34;,</span>
<span num="68">            &#34;http://golang.org/pkg/os/&#34;,</span>
<span num="69">        },</span>
<span num="70">    },</span>
<span num="71">    &#34;http://golang.org/pkg/fmt/&#34;: &amp;fakeResult{</span>
<span num="72">        &#34;Package fmt&#34;,</span>
<span num="73">        []string{</span>
<span num="74">            &#34;http://golang.org/&#34;,</span>
<span num="75">            &#34;http://golang.org/pkg/&#34;,</span>
<span num="76">        },</span>
<span num="77">    },</span>
<span num="78">    &#34;http://golang.org/pkg/os/&#34;: &amp;fakeResult{</span>
<span num="79">        &#34;Package os&#34;,</span>
<span num="80">        []string{</span>
<span num="81">            &#34;http://golang.org/&#34;,</span>
<span num="82">            &#34;http://golang.org/pkg/&#34;,</span>
<span num="83">        },</span>
<span num="84">    },</span>
<span num="85">}</span>
</pre>


</div>


</div>

<div class="slide nocode">
	
  <h2>더 살펴볼 곳 들...</h2>
  
  
  <p>
    우선 <a href="http://golang.org/doc/" target="_blank">Go 문서</a> 사이트에서 시작하는 것이 좋습니다. 여기에서 레퍼런스, 튜토리얼, 비디오 등의 자료를 볼 수 있습니다.
  </p>
  

  
  <p>
    고 코드를 구성하기와 고로 작업하는 방법을 배우려면, <a href="http://www.youtube.com/watch?v=XCsL89YtqCs" target="_blank">이 스크린캐스트</a>를 보거나, <a href="http://golang.org/doc/code.html" target="_blank">고 코드 작성 방법</a>를 읽어 보세요.
  </p>
  

  
  <p>
    표준 라이브러리에 대한 도움이 필요하면, <a href="http://golang.org/pkg/" target="_blank">패키지 레퍼런스</a>를 살펴보세요. 고 언어 자체에 대해서는 <a href="http://golang.org/ref/spec" target="_blank">언어 스펙</a>이 도움이 되며, 아마 꽤 쉽게 스펙문서를 읽을 수 있음에 놀라게 될 것입니다.
  </p>
  

  
  <p>
    더 나아가 고의 동시성(concurrency) 모델을 살펴보려면 코드워크, <a href="http://golang.org/doc/codewalk/sharemem/" target="_blank">통신으로 메모리 공유하기</a>를 보세요.
  </p>
  

  
  <p>
    코드워크, <a href="http://golang.org/doc/codewalk/functions/" target="_blank">First Class Functions in Go</a>에서는 고의 함수 타입에 관련된 흥미로운 관점을 제공합니다.
  </p>
  

  
  <p>
    공식 블로그, <a href="http://blog.golang.org/" target="_blank">Go </a>에는 유익한 기사들이 많이 있습니다.
  </p>
  

  
  <p>
    공식 사이트 <a href="http://golang.org" target="_blank">golang.org</a>를 방문해 더 살펴보세요.
  </p>
  

  
  <p>
    번역: <a href="https://developers.google.com/groups/chapter/112714242728066184635/" target="_blank">한국 Go 언어 커뮤니티(GDG Korea Golang)</a>
  </p>
  


</div>


</div>

<div id="workspace">
	<div class="controls">
		<div><a id="run" href="#run" title="Compile and Run">Run</a><a href="#more" id="more" title="Options">▼</a></div>
		<ul class="more">
			<li><a href="#" id="reset">Reset Slide</a></li>
			<li><a href="#" id="format">Format Source Code</a></li>
			<li><a href="#" id="kill" class="localMode">Kill Program</a></li>
			<li><hr></li>
			<li><a href="#" id="togglesyntax">Syntax-Highlighting: off</a></li>
			<li><a href="#" id="togglelineno">Line-Numbers: on</a></li>
		</ul>
	</div>

	<div id="workspace-top">
		<div id="workspace-editor">
			<textarea id="editor" spellcheck="false"></textarea>
		</div>
	</div>

	<div id="workspace-bottom">
		<div id="output"></div>
	</div>
</div>
</div>

</body>
</html>
